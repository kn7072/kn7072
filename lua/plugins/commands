https://neovim.io/doc/user/lua.html

Displays a notification to the user. 
vim.log.levels Log levels are one of the values defined in vim.log.levels:
vim.log.levels.DEBUG vim.log.levels.ERROR vim.log.levels.INFO vim.log.levels.TRACE vim.log.levels.WARN vim.log.levels.OFF 

lua vim.notify("msg", vim.log.levels.DEBUG)

Parameters:
{msg} (string) Content of the notification to show to the user.
{level} (integer?) One of the values from vim.log.levels.
{opts} (table?) Optional parameters. Unused by default.

nvim_buf_lines_event
:echo b:changedtick
lua print(vim.b["changedtick"])

        lua vim.api.nvim_buf_lines_event(vim.api.nvim_get_current_buf(), 3, 1, 3, {"1", "2", "3"}, true)   b:changedtick
        lua vim.api.nvim_buf_lines_event(vim.api.nvim_get_current_buf(), 1, 1, 1, {"1" }, false)
        lua vim.api.nvim_buf_lines_event[vim.api.nvim_get_current_buf(), {changedtick}, 0, 0, ["line1", "line2"], false]

изменить текст в сроках
lua vim.api.nvim_buf_set_text(vim.api.nvim_get_current_buf(), 20, 1, 23, 1, {"1", "2", "3"})
({buffer}, {start_row}, {start_col}, {end_row}, {end_col}, {replacement}) Sets (replaces) a range in the buffer 

изменить текст в сроках - предпочтительней чем nvim_buf_set_text
lua vim.api.nvim_buf_set_lines(vim.api.nvim_get_current_buf(), 20, 25, false, {"1", "2", "3"})
{buffer}, {start}, {end}, {strict_indexing}, {replacement}


число строк в буфере 0
lua print(vim.api.nvim_bug_line_count(0))

получить строки
lua print(vim.inspect(vim.api.nvim_buf_get_lines(0, 0, 3, true)))
(buf, firstline, new_lastline, true)

сделает активным текущий буфер, то есть в текущем окне отобразиться содержимое буфера
api.nvim_set_current_buf(plugin_buffer)

сделает активным указанное окно
api.nvim_set_current_win(window_id)

##################################################
nvim_get_hl({ns_id}, {opts})
nvim_get_hl() Gets all or specific highlight groups in a namespace. 

lua vim.api.nvim_create_namespace()

посмотрить какие hl у namespace
lua ns_id = vim.api.nvim_create_namespace("plugin_ns"); print(vim.inspect(vim.api.nvim_get_hl(ns_id, {name="Myhl"})))
lua print(vim.inspect(vim.api.nvim_get_hl(0, {name="BlackOnLightYellowBuffer"}))) ранее добавлен в плагине BlackOnLightYellowBuffer
lua print(vim.inspect(vim.api.nvim_get_hl(0, {}))) посмотрить все стили

    lua print(vim.api.nvim_set_hl_ns(0))
    nvim_set_hl_ns() Set active namespace for highlights defined with nvim_set_hl() This can be set for a single window, see            nvim_win_set_hl_ns(). 

идентификатор hl
lua print(vim.api.nvim_get_hl_id_by_name("BlackOnLightYellowBuffer"))
nvim_get_hl_id_by_name() Gets a highlight group by name

    lua print(vim.api.nvim_get_hl_ns({windid = vim.api.nvim_get_current_win()}))
    nvim_get_hl_ns() Gets the active highlight namespace.


nvim_win_set_hl_ns({window}, {ns_id})
nvim_win_set_hl_ns() Set highlight namespace for a window.

lua ns_id = vim.api.nvim_create_namespace("plugin_ns"); vim.api.nvim_set_hl(ns_id, 'ColorStudyPlugin', {ctermbg = 0, fg = '#000000', bg = '#e5c07b', bold = true}); vim.api.nvim_win_set_hl_ns(0, ns_id)

api.nvim_set_option_value('filetype', 'markdown', {buf = buf})
api.nvim_set_option_value('winhl', 'Normal:BlackOnLightYellow', {win = win})
##################################################
nvim_get_current_win()
nvim_get_current_win() Gets the current window. 

текущее окно
lua print(vim.api.nvim_get_current_win())

lua require'study'.pick()
lua require'study'.print_hl() 


lua print(vim.api.nvim_tabpage_get_number(0))  1
lua print(vim.inspect(vim.api.nvim_tabpage_list_wins(0)))  1000
lua print(vim.inspect(vim.api.nvim_tabpage_get_var(0)))

lua print(vim.inspect(vim.fn.tabpagenr()))

set showtabline=2
The value of this option specifies when the line with tab page labels
	will be displayed:
		0: never
		1: only if there are at least two tab pages
		2: always	
:set tabline  узнать текущее значение
:set tabline=%f

##################################################
zR : opens all folders
zM : collapses all folders
zo : opens the folder you're in (1 level)
zO : opens all folders recursively at the cursor line
zc : collapses the folder you're in (1 level)
zC : collapses all folders recursively at the cursor line
zn : deactivates folding
zN : restores folding to previous state
zi : toggles between zn and zN
za : Toggle between closing and opening the fold under the cursor.

fold							*:syn-fold*

The "fold" argument makes the fold level increase by one for this item.
Example:  
   :syn region myFold start="{" end="}" transparent fold
   :syn sync fromstart
   :set foldmethod=syntax
This will make each {} block form one fold.

The fold will start on the line where the item starts, and end where the item
ends.  If the start and end are within the same line, there is no fold.
The 'foldnestmax' option limits the nesting of syntax folds.
See |:syn-foldlevel| to control how the foldlevel of a line is computed
from its syntax items.


syn region  luaFunctionBlock     matchgroup=luaFunction start="function" end="end" contains=ALLBUT transparent fold

после ввода команды нужно нажать zc чтобы отобразились подсказки 
syn region  luaFunctionBlock     matchgroup=luaFunction start="function" end="end" contains=ALLBUT,luaTodo,luaSpecial,luaCond,luaCondElseif,luaCondEnd,luaRepeat transparent fold

сразу выделяет фрагменты
syn region  luaFunctionBlock  transparent   matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=ALLBUT,luaTodo,luaSpecial,luaCond,luaCondElseif,luaCondEnd,luaRepeat  fold

автоматически сварачивает все что начинается с h
set foldmethod=expr
set foldexpr=getline(v:lnum)[0]==\"h\"
##################################################
https://github.com/nanotee/nvim-lua-guide

:help lua-vim-variables

These wrappers also have more sophisticated vim.opt* variants that provide convenient mechanisms for setting options in Lua. They're similar to what you might be used to in your init.vim:

    vim.opt: behaves like :set
    vim.opt_global: behaves like :setglobal
    vim.opt_local: behaves like :setlocal


