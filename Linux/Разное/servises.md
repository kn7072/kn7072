# Пишем systemd Unit файл

Systemd Unit — это скрипт, который выполняет различные действия ( все то, что пропишешь в него). Я обычно пишу такие скрипты для запуска различных служб которые компилирую руками или когда использую готовое ПО.

Что дадут вам Systemd юниты?

Units — это объекты, которыми может управлять система (В основном — стандартизированное представление системных ресурсов, которыми может управлять набор демонов).

Units, в некотором смысле можно назвать службами или заданиями, однако юнит имеет гораздо более широкое определение, поскольку он может использоваться для абстрактных служб, сетевых ресурсов, устройств, монтирования файловой системы и изолированных пулов ресурсов.

Некоторые функции, которые легко реализовать:

- Активация на основе сокетов: Сокеты, связанные с сервисом, лучше всего вырываются из самого демона, чтобы обрабатываться отдельно. Это дает ряд преимуществ,- например, задержка запуска службы до тех пор, пока соответствующий сокет не будет доступен. Это также позволяет системе создавать все сокеты до начала запуска процесса, что позволяет параллельно загружать связанные службы.
- Активация на основе шины: Unit-ы также могут быть активированы на интерфейсе шины, предоставляемом D-Bus-ом. Устройство может быть запущено когда соответствующая шина доступна.
- Активация на основе пути: Unit может быть запущен на основе активности или наличия определенных путей к файловой системе. Это использует inotify.
- Активация на основе устройства: Unit-ы также могут быть запущены при первой доступности  (подключении) связанного оборудования за счет использования событий udev.
- Неявное сопоставление зависимостей: Большая часть структуры зависимостей для юнитов может быть построена самой системой. Вы все равно можете добавить информацию о зависимостях, но большая часть тяжелой работы будет решена за вас.
- Экземпляры и шаблоны: Файлы блока шаблонов могут использоваться для создания нескольких экземпляров одного и того же общего устройства. Это позволяет создавать небольшие вариации или единичные unit-ы, которые обеспечивают одну и ту же общую функцию.
- Простое упрощение безопасности: Юниты могут реализовать некоторые довольно хорошие функции безопасности, добавив простые директивы. Например, вы можете указать какой доступ можно использовать ( чтение, запись) при работе с файловой системой, ограничить возможности ядра, установить приватный /tmp фолдер и сетевой доступ.
- Drop-ins и snippets: Units можно легко расширить, предоставив фрагменты, которые будут отменять части файла системы. Это позволяет легко переключаться между vanilla и индивидуальными реализациями.

Есть много других преимуществ, которые имеют системные юниты над рабочими элементами других систем, но это должно дать вам представление о мощности, которую можно использовать с помощью собственных конфигурационных директив.

## Как я могу найти/ Где находятся Systemd Unit в Unix/Linux? ##

Файлы, определяющие, как systemd будет обрабатывать unit, можно найти в разных местах, каждое из которых имеет разные приоритеты и смысл.

Все копии системных файлов системы (я имею ввиду всех юнитов) можно найти в __/lib/systemd/system__ каталоге. Файлы, хранящиеся здесь, могут быть запущены и остановлены по требованию, но во время сеанса. Это будет общий файл ванильной единицы, который часто записывается сторонними разработчиками проекта, которые должны работать в любой системе, которая развертывает systemd в своей стандартной реализации. Вы не должны редактировать файлы в этом каталоге. Вместо этого вы должны переопределить файл (если необходимо) используя другое расположение файла, которое заменит файл в этом месте.

Если вы хотите изменить работу некоторого  устройства, то для этого нужно перейти в /etc/systemd/system директорию, потому что — файлы, найденные в этом каталоге, имеют приоритет над любыми другими местами в файловой системы.

Если вы хотите переопределить только определенные директивы из системных unit файлов, вы можете фактически предоставить фрагменты unit файла в подкаталоге. Они будут добавлять или изменять директивами копии системы, позволяя указать только параметры, которые вы хотите изменить.

Правильный способ сделать это — создать каталог с именем после файла с добавлением «.d» в конце. Таким образом, для единицы под названием my_test.service нужно создать подкаталог my_test.service.d. В этом каталоге файл, заканчивающийся на .conf, может использоваться для переопределения или расширения атрибутов unit файла.

Также есть место для определения run-time unit-ов  в /run/systemd/system. Файлы, найденные в этом каталоге, имеют приоритет между /etc/systemd/system и/lib/systemd/system.

Файлы в этом месте дают меньший приоритет, чем прежнее местоположение, но больший приоритет, чем последнее. Сам процесс systemd использует это местоположение для динамически создаваемых unit файлов, созданных во время выполнения. Этот каталог можно использовать для изменения поведения устройства системы в течение всего сеанса. Все изменения, внесенные в этот каталог, будут потеряны при перезагрузке сервера.

# Как создать свой сервис для Linux

Если вы еще никогда не делали свои сервисы, начнем с основ. Systemd оперирует абстрактными единицами (unit), которые бывают разных типов, могут предоставлять различные ресурсы (процессы, сокеты, абстрактные «цели») и требовать других ресурсов для запуска.

Самый распространенный вид ресурса — сервис (service). Файлы с описаниями сервисов и всего прочего лежат в каталоге __/lib/systemd/system/__. Чтобы systemd нашел новый сервис, достаточно положить в этот каталог свой файл. Если этот сервис ранее не существовал, systemd прочитает файл и загрузит его в память. Однако, если вы редактируете файл ранее запущенного сервиса, не забудьте заставить systemd перечитать файлы командой 
__sudo systemctl daemon-reload__

## Создание Сервиса в Systemd
https://darksf.ru/2018/03/30/systemd-sozdanie-servisa-primery/

Создайте service-файл /etc/systemd/system/foo-daemon.service (замените foo-daemon на имя вашего сервиса):
- __$ sudo touch /etc/systemd/system/foo-daemon.service__
- __$ sudo chmod 664 /etc/systemd/system/foo-daemon.service__
Откройте файл foo-daemon.service и пропишите минимальные настройки, которые позволят управлять сервисом с помощью systemctl:
	
[Unit]
Description=Foo
 
[Service]
ExecStart=/usr/sbin/foo-daemon
 
[Install]
WantedBy=multi-user.target

После создания нового service-файла необходимо перезапустить systemd: 
__sudo systemctl daemon-reload__

Теперь вы можете делать start, stop, restart и проверять status сервиса:
__$ sudo systemctl start foo-daemon__
__$ sudo systemctl stop foo-daemon__
__$ sudo systemctl restart foo-daemon__
__$ systemctl status foo-daemon__

Чтобы добавить сервис в автозагрузку, необходимо активировать его:
__$ sudo systemctl enable foo-daemon__

Чтобы проверить логи сервиса, выполните:
__$ journalctl -u foo-daemon__

# Опции Service-файла в Systemd

- Service-файла в systemd обычно состоит из трех секций.
- Общие элементы конфигурации сервиса настраиваются в секциях [Unit] и [Install]
- Параметры конфигурации конкретного сервиса настраиваются в секции [Service].

## Важные Опции Секции [Unit]
Первый раздел, найденный в большинстве юнит-файлов, — это раздел [Unit]. Обычно его используют для определения метаданных устройства и настройки отношения устройства к другим устройствам.

Хотя порядок разделов не имеет значения для systemd при парсинге файла, этот раздел часто размещается сверху, потому что он предоставляет обзор устройства. Некоторые общие директивы, которые вы найдете в разделе [Unit]

Список всех опций секции [Unit]: __$ man systemd.unit__

- __Description__	Краткое описание юнита.
- __Documentation__	Список ссылок на документацию.
- __Before, After__	Порядок запуска юнитов.
- __Requires__ Если этот сервис активируется, перечисленные здесь юниты тоже будут активированы. Если один из перечисленных юнитов останавливается или падает, этот сервис тоже будет остановлен.
- __Wants__	Устанавливает более слабые зависимости, чем Requires. Если один из перечисленных юнитов не может успешно запуститься, это не повлияет на запуск данного сервиса. Это рекомендуемый способ установления зависимостей.
- __Conflicts__	Если установлено что данный сервис конфликтует с другим юнитом, то запуск последнего остановит этот сервис и наоборот.

## Важные Опции Секции [Install]
В самом конце файла, расположен — [Install] секция. Этот раздел является дополнительным и используется для определения поведения или юнита, если он включен или отключен. Включение устройства означает, что он автоматически запускается при загрузке. По сути, это достигается путем фиксации рассматриваемого устройства на другом блоке, который находится где-то в строке единиц, которые нужно запустить при загрузке.
Из-за этого, только юниты, которые могут быть включены, будут иметь этот раздел. Директивы внутри, говорят что должно произойти, когда устройство включено:

Список всех опций секции [Install]: __$ man systemd.unit__

- __Alias__	Дополнительные имена сервиса разделенные пробелами. Большинство команд в systemctl, за исключением systemctl enable, могут использовать альтернативные имена сервисов.
- __WantedBy__ Данная директива, является наиболее распространенным способом определения того, как устройство должно быть включено. Эта директива позволяет вам указать зависимость ( аналогично директиве Wants = в разделе [Unit]). Разница в том, что эта директива включена в вспомогательную единицу, позволяющую первичному блоку оставаться относительно чистым. Когда устройство с этой директивой определено, то будет создана в системе  папка в /etc/systemd/, названная в честь указанного устройства, но с добавлением «.wants» в самом конце. В этом случае будет создана символическая ссылка на текущий блок, создающий зависимость. Например, если текущий блок имеет WantedBy = multi-user.target, каталог с именем multi-user.target.wants будет создан в/etc/systemd/system (если он еще не доступен) и символическая ссылка на текущий блок будут размещены внутри. Отключение этого устройства удаляет связь и удаляет зависимость.
- __RequiredBy__ Эта директива очень похожа на директиву WantedBy =, но вместо этого указывает требуемую зависимость, которая приведет к сбою активации, если не будет выполнена. Когда включено, юнит с этой директивой создаст каталог, заканчивающийся на .requires.
- __Also__	Определяет список юнитов, которые также будут активированы или дезактивированы вместе с данным сервисом при выполнении команд systemctl enable или systemctl disable.
- __DefaultInstance__ Для template units (более поздних), которые могут создавать экземпляры блоков с непредсказуемыми именами, это может использоваться как резервное значение для имени, если соответствующее имя не предоставляется.

## Важные Опции Секции [Service]
Раздел [Service] используется для предоставления конфигурации, которая применима только для служб. Одной из основных вещей, которые должны быть указаны в разделе [Service], является Type= служба. Это классифицирует услуги по их процессу и демонизирующему поведению. Это важно, потому что он сообщает systemd, как правильно управлять службой и узнать его состояние.

Список всех опций секции [Service]: __$ man systemd.service__

- __Type__	Настраивает тип запуска процесса. Один из:
__simple__ (по умолчанию) — запускает сервис мгновенно. Предполагается, что основной процесс сервиса задан в ExecStart.
__forking__ — считает сервис запущенным после того, как родительский процесс создает процесс-потомка, а сам завершится. Этот тип службы используется, когда служба форкает дочерние процессы при мгновенном покидании родительского процесса. Это сообщает systemd, что процесс все еще работает, даже несмотря на то, что родитель завершил сеанс. Хорошо подходит, например для запуска php-fpm, nginx, tomcat.
__oneshot__ — аналогичен типу simple, но предполагается, что процесс должен завершиться до того, как systemd начнет отслеживать состояния юнитов (удобно для скриптов, которые выполняют разовую работу и завершаются). Возможно вы также захотите использовать __RemainAfterExit=yes__, чтобы systemd продолжал считать сервис активным и после завершения процесса.
__dbus__ — аналогичен типу simple, но считает сервис запущенным после того, как основной процесс получает имя на шине D-Bus.
__notify__ — аналогичен типу simple, но считает сервис запущенным после того, как он отправляет systemd специальный сигнал. Это указывает на то, что служба отправит уведомление, когда закончит запуск. Процесс systemd будет ждать, пока это произойдет, прежде чем переходить к другим устройствам.
__idle__ — аналогичен типу simple, но фактический запуск исполняемого файла сервиса откладывается, пока не будут выполнены все задачи.

### При использовании определенных типов служб, могут потребоваться некоторые дополнительные директивы. Например:

- __RemainAfterExit__	Если установлена в значение True, сервис будет считаться запущенным даже если сам процесс завершен. Полезен с __Type=oneshot__. Значение по умолчанию False.

- __PIDFile__ Если тип службы отмечен как «forking», эта директива используется для установки пути файла, который должен содержать идентификационный номер процесса основного «ребенка», который должен контролироваться.

- __BusName__ Эта директива должна быть установлена на имя шины D-Bus, которое служба попытается получить при использовании типа службы «dbus».

- __NotifyAccess__ Эта директива указывает на доступ к сокету, который должен использовать для прослушивания уведомлений при выборе «notify». Она может быть «none», «main» или «all». По умолчанию «none» игнорирует все сообщения о состоянии. «main» вариант будет прослушивать сообщения из основного процесса, а опция «all» приведет к обработке всех членов контрольной группы службы.

### До сих пор мы обсуждали некоторую предварительную информацию, но фактически не говорили, как управлять нашими услугами. Для этого имеются следующие директивы:

- __ExecStart__	Команды вместе с аргументами, которые будут выполнены при старте сервиса. Опция __Type=oneshot__ позволяет указывать несколько команд, которые будут выполняться последовательно. Опции __ExecStartPre__ и __ExecStartPost__ могут задавать дополнительные команды, которые будут выполнены до или после __ExecStart__.

- __ExecStop__	Команды, которые будут выполнены для остановки сервиса запущенного с помощью __ExecStart__.

- __ExecReload__ Команды, которые будут выполнены чтобы сообщить сервису о необходимости перечитать конфигурационные файлы.

- __Restart__	Если эта опция активирована, сервис будет перезапущен если процесс прекращен или достигнут timeout, за исключением случая нормальной остановки сервиса с помощью команды __systemctl stop__. Она может быть установлена как значения __always__, __on-success__, __on-failure__, __on-abnormal__, __on-abort__ или __on-watchdog__. Это приведет к перезапуску в соответствии с тем, как служба была остановлена.

-__RestartSec__ Если автоматический перезапуск службы включен, это указывает время ожидания перед попыткой перезапуска службы.

-__TimeoutSec__ Это устанавливает время, в течение которого система будет ждать остановки службы, прежде чем пометить ее как неудачную или убитую принудительно. Вы можете установить отдельные таймауты с помощью __TimeoutStartSec=__ и T__imeoutStopSec=__.

-__StandardOutput__ Чтобы писать лог Output в файл file:/path/to/file(Т.е. после знака «=» нужен «file:») пример StandardOutput=file:/home/stapan/TMP/output.log

-__StandardError__ Чтобы писать лог Error в файл file:/path/to/file(Т.е. после знака «=» нужен «file:») пример StandardError=file:/home/stapan/TMP/error.log

## Важные Опции Секции [Socket]
Socket очень часто встречаются в конфигурациях systemd, потому что многие службы реализуют активацию на основе сокетов, чтобы обеспечить лучшую распараллеливание и гибкость. Каждый блок socket-а должен иметь соответствующий сервисный модуль, который будет активирован, когда сокет получает активность.

Разрушая управление сокета вне самой службы, сокеты могут быть инициализированы раньше, и связанные службы могут часто запускаться параллельно. По умолчанию имя сокета будет пытаться запустить службу с тем же именем после получения соединения. Когда служба инициализируется, сокет будет передан ему, что позволит ему начать обработку любых буферизованных запросов.

Чтобы указать фактический сокет, эти директивы являются общими:

-__ListenStream__ Это определяет адрес для сокет stream, который поддерживает последовательную, надежную связь. Службы, использующие TCP, должны использовать этот тип сокета.
-__ListenDatagram__ Это определяет адрес для сокет datagram, который поддерживает быстрые, ненадежные пакеты связи. Службы, использующие UDP, должны устанавливать этот тип сокета.
-__ListenSequentialPacket__ Это определяет адрес для последовательной, надежной связи с максимальными дейтаграммами, которые сохраняют границы сообщений. Это чаще всего встречается для Unix сокетов.
-__ListenFIFO__ Наряду с другими типами прослушивания вы также можете указать буфер FIFO вместо сокета.

Существует больше типов директив для установки соединений, но те которые указаны выше, являются наиболее распространенными.

Другие характеристики сокетов можно контролировать с помощью дополнительных директив:

__Accept__ Это определяет, будет ли запущен дополнительный экземпляр службы для каждого соединения. Если установлено значение false (по умолчанию), один экземпляр будет обрабатывать все соединения.
__SocketUser__ С помощью Unix-сокета задается его владелец. Если не указать, то будет пользователь root.
__SocketGroup__ С помощью Unix-сокета задается владелец группы. Это будет root группа, если не указано ни то, ни другое. Если установлен только SocketUser =, systemd попытается найти подходящую группу.
__SocketMode__ Для сокетов Unix или буферов FIFO это устанавливает разрешения для созданного объекта.
__Service__ Если имя службы не совпадает с именем .socket, эта служба может быть указана с помощью этой директивы.


## Важные Опции Секции [Mount]
Модули монтирования позволяют управлять точкой монтирования изнутри systemd. Точки монтирования называются в соответствии с управляемым им каталогом с применением алгоритма перевода.

Например, ведущая косая черта (слеш или «/») удаляется, все остальные косые черты переводится в тире «-», и все тире и непечатаемые символы заменяются escape-кодами стиля С. Результат этого перевода используется как имя узла монтирования. Unit-ы монтирования будут иметь неявную зависимость от других монтировок над ней в иерархии.

Mount юниты часто переводятся непосредственно из файла /etc/fstab во время процесса загрузки. Для автоматически созданных определений единиц и те, которые вы хотите определить в единичном файле:

__What__ Абсолютный путь к ресурсу, который необходимо смонтировать.
__Where__ Абсолютный путь точки монтирования, в которой должен быть установлен ресурс. Это должно быть таким же, как имя файла устройства, за исключением использования стандартной записи файловой системы.
__Type__ Тип файловой системы для монтирования.
__Options__ Любые параметры монтирования, которые необходимо применить. Это список, разделенный запятыми.
__SloppyOptions__ Логическое значение (0 или 1), которое определяет произойдет ли сбой монтирования, если есть параметр непризнанного монтирования.
__DirectoryMode__ Если родительские каталоги необходимо создать для точки монтирования, это определяет режим разрешений этих папок.
__TimeoutSec__ Настраивает время, в течение которого система будет ждать, пока операция монтирования не будет отмечена как сбой.

## Важные Опции Секции [Automount]
Этот модуль позволяет автоматически устанавливать подключенный модуль .mount при загрузке. Как и в случае с модулем .mount, эти юниты должны быть названы в честь пути переведенной точки монтирования.

[Automount] Раздел довольно прост, разрешены только следующие два варианта:

__Where__ Абсолютный путь automount в файловой системе. Это будет соответствовать имени файла, за исключением того, что вместо перевода используется условное обозначение пути.
__DirectoryMode__ Если необходимо создать automount или любые родительские каталоги, это определит настройки разрешений для этих компонентов пути.

## Важные Опции Секции [Swap]
Swap модули используются для настройки подкачки (свопинга) в системе. Юниты должны быть названы по названию файла или устройства подкачки, используя тот же перенос файловой системы, о котором говорилось выше.
Как и mount параметры, блоки swap могут быть автоматически созданы из /etc/fstab или могут быть сконфигурированы через выделенный unit файл.

Раздел [Swap] может содержать следующие директивы для конфигурации:

__What__ Абсолютный путь к местоположению подкачки (будь то файл или устройство).
__Priority__ Данная опция принимает целое число, которое задает приоритет для настройки подкачки.
__Options__ Любые параметры, которые обычно задаются в файле /etc/fstab, могут быть установлены с помощью этой директивы. Используется список, разделенный запятыми.
__TimeoutSec__ Данная опция задает временя, в течение которого, система ожидает активацию своп-а, прежде чем отмечать операцию как зафейленую.

## Важные Опции Секции [Path]
Блок path, определяет путь файловой системы, который systmed может отслеживать изменения. Должен существовать другой блок, который будет активирован, когда определенная активность будет обнаружена в местоположении пути. Активность пути определяется тем, что он не влияет на события.

Раздел [Path] может содержать следующие директивы:

__PathExists__ Эта директива используется для проверки того, существует ли этот путь. Если путь существует, активируется соответствующий блок.
__PathExistsGlob__ Данная опция такая как и выше, но поддерживает глобальные выражения для определения существования пути.
__PathChanged__ Данную опцию используют для отслеживания изменений местоположение пути. Связанный блок активируется, если обнаружено изменение (проверяется когда файл закрыт).
__PathModified__ Данная опция такая как и выше, но активируется при записи файлов, а также когда файл закрыт.
__DirectoryNotEmpty__ Эта директива позволяет systemd активировать связанный блок, когда каталог больше не пустой.
__Unit__ Это указывает, что устройство активируется, когда условия пути, указанные выше, выполняются. Если это будет опущено, systemd будет искать файл .service, который имеет то же имя базового юнита, что и этот блок.
__MakeDirectory__ Данная директива определяет, будет ли systemd создавать структуру каталогов перед просмотром.
__DirectoryMode__ Если вышеуказанная директива включена, то данная опция установит режим разрешения любых компонентов пути, которые должны быть созданы.

## Важные Опции Секции [Timer]
Timer юнит,  используются для планирования задач для работы в определенное время или после определенной задержки. Этот тип устройства заменяет или дополняет некоторые функции cron-а и демонов. Должен быть предоставлен соответствующий блок, который будет активирован, когда таймер будет достигнут.
Раздел [Timer] может содержать некоторые из следующих директив:

__OnActiveSec__ Эта директива позволяет активировать соответствующий блок относительно активации модуля .timer.
__OnBootSec__ Эта директива задает время, когда будет активироваться соответствующее  устройство после загрузки системы.
__OnStartupSec__ Эта директива аналогична указанному выше таймеру, но задает когда будет активироваться systemd процесс после загрузки системы.
__OnUnitActiveSec__ Это устанавливает таймер в зависимости от того, когда последний активировался.
__OnUnitInactiveSec__ Это устанавливает таймер в отношении того когда unit был неактивный.
__OnCalendar__ Это позволяет активировать соответствующий блок путем определения абсолютного (вместо относительно).
__AccuracySec__ Данный юнит используется для установки уровня точности с таймером, который должен быть приклеен. По умолчанию, связанный с ним блок будет активирован в течение одной минуты.
__Unit__ Эта директива используется для указания того, что необходимо активировать когда таймер истечет. Если не установлены, Systemd будет искать блок с именем .service.
__Persistent__ Если это установлено, Systemd запустит триггер соответствующего блока.
__WakeSystem__ Установка этой директивы позволяет «будить систему» из режима ожидания, если таймер будет достигнут.

## Важные Опции Секции [Slice]
Раздел [Slice] на самом деле, не имеет .slice специфической конфигурации. Вместо этого он может содержать некоторые директивы управления ресурсами, которые перечислялись выше.

## Ниже приведены некоторые из наиболее распространенных спецификаторов, которые будут заменены, когда юнит-экземпляра интерпретируется с соответствующей информацией:

    %n: В любом месте, где это используется, будет добавлено полное имя элемента.
    %N: Это то же самое, что и выше, но любое экранирование, такое как те, что присутствуют в шаблонах пути файла, будет отменено.
    %p: Это указывает префикс имени юнита. Это часть названия юнита, которая предшествует символу @.
    %P: Это то же самое что и выше, но с любым отступлением.
    %i: Это ссылается на имя экземпляра, которое является идентификатором, следующим за @ в экземпляре. Это один из наиболее часто используемых спецификаторов, поскольку он динамичный. Использование этого идентификатора поощряет использование значимых идентификаторов конфигурации. Например, порт, в котором будет выполняться служба, может использоваться как идентификатор экземпляра, и шаблон может использовать этот спецификатор для настройки спецификации порта.
    %I: Этот спецификатор такой же, как и выше, но с любым отступлением.
    %f: Это будет заменено на имя неэкранированного юнита или имя префикса, добавленное к «/».
    %c: Это будет указывать на управляющую группу устройства со стандартной родительской иерархией /sys/fs/cgroup/ssytemd.
    %u: Имя пользователя, настроенного для запуска юнита.
    %U: То же, что и выше, UID вместо имени.
    %H: Имя хоста системы, на котором выполняется юнит.
    %%: Это используется для вставки буквенного знака процента.

Используя приведенные выше идентификаторы в шаблоне файла, Systemd заполнит правильные значения при интерпретации шаблона для создания юнит-экземпляра.

## Примеры Service-файлов в Systemd

[Unit]
Description=The NGINX HTTP and reverse proxy server
After=syslog.target network.target remote-fs.target nss-lookup.target
 
[Service]
Type=forking
PIDFile=/run/nginx.pid
ExecStartPre=/usr/sbin/nginx -t
ExecStart=/usr/sbin/nginx
ExecReload=/bin/kill -s HUP $MAINPID
ExecStop=/bin/kill -s QUIT $MAINPID
PrivateTmp=true
 
[Install]
WantedBy=multi-user.target

---

[Unit]
Description=The Apache HTTP Server
After=network.target remote-fs.target nss-lookup.target
 
[Service]
Type=notify
EnvironmentFile=/etc/sysconfig/httpd
ExecStart=/usr/sbin/httpd $OPTIONS -DFOREGROUND
ExecReload=/usr/sbin/httpd $OPTIONS -k graceful
ExecStop=/bin/kill -WINCH ${MAINPID}
KillSignal=SIGCONT
PrivateTmp=true
 
[Install]
WantedBy=multi-user.target

---

[Unit]
Description=Redis persistent key-value database
After=network.target
 
[Service]
ExecStart=/usr/bin/redis-server /etc/redis.conf --daemonize no
ExecStop=/usr/bin/redis-shutdown
User=redis
Group=redis
 
[Install]
WantedBy=multi-user.target

---

# Документация
https://www.freedesktop.org/software/systemd/man/systemd.service.html
https://www.freedesktop.org/software/systemd/man/systemd.unit.html
https://linux-notes.org/pishem-systemd-unit-fajl/