
Неважно, являетесь ли вы системным администратором или простым энтузиастом, скорее всего, вам придется часто работать с текстовыми документами. Linux, как и другие Unices, предоставляет конечным пользователям одни из лучших утилит для работы с текстом. Утилита командной строки sed — один из таких инструментов, который делает обработку текста гораздо более удобной и продуктивной. Если вы опытный пользователь, вы уже должны знать о sed. Однако новички часто чувствуют, что изучение sed требует дополнительных усилий, и поэтому воздерживаются от использования этого завораживающего инструмента. Вот почему мы взяли на себя смелость создать это руководство и помочь им освоить основы sed как можно проще.

## **Полезные команды SED для начинающих пользователей**

---

Sed — одна из трех широко используемых утилит фильтрации, доступных в Unix (остальные — «grep и awk»). Мы уже рассмотрели команду Linux grep и команду awk для начинающих. Целью данного руководства является ознакомление с утилитой sed для начинающих пользователей и обучение их навыкам обработки текста с использованием Linux и других Unices.

## **Как работает SED: базовое понимание**

---

Прежде чем непосредственно углубляться в примеры, вы должны иметь четкое представление о том, как работает sed в целом. Sed — потоковый редактор, созданный на основе утилиты ed. Это позволяет нам вносить изменения в поток текстовых данных. Хотя для редактирования мы можем использовать ряд текстовых редакторов Linux, sed позволяет сделать что-то более удобное.

Вы можете использовать sed для преобразования текста или фильтрации важных данных на лету. Он соответствует основной философии Unix, очень хорошо выполняя эту конкретную задачу. Более того, sed очень хорошо работает со стандартными инструментами и командами терминала Linux. Таким образом, он больше подходит для многих задач по сравнению с традиционными текстовыми редакторами.

[![](media/sed-working-principle.png.webp)](https://ru.linux-terminal.com/common-images/practical-examples-of-the-sed-command-in-linux/sed-working-principle.png)

По своей сути sed принимает некоторые входные данные, выполняет некоторые манипуляции и выдает выходные данные. Он не меняет ввод, а просто показывает результат в стандартном выводе. Мы можем легко сделать эти изменения постоянными, перенаправив ввод-вывод или изменив исходный файл. Основной синтаксис команды sed показан ниже.

```powershell
sed [OPTIONS] INPUT
sed 'list of ed commands' filename
```

Первая строка — это синтаксис, показанный в руководстве по sed. Второй легче понять. Не волнуйтесь, если вы сейчас не знакомы с командами ed. Вы изучите их в этом руководстве.

### **1. Замена ввода текста**

---

Команда замены — наиболее широко используемая функция sed для многих пользователей. Это позволяет нам заменить часть текста другими данными. Вы очень часто будете использовать эту команду для обработки текстовых данных. Это работает следующим образом.

```powershell
$ echo 'Hello world!' | sed 's/world/universe/'
```

Эта команда выведет строку «Привет, вселенная!». Он состоит из четырех основных частей. Команда **'s'** обозначает операцию замены, /../../ являются разделителями, первая часть внутри разделителей — это шаблон, который необходимо изменить, а последняя часть — строка замены. .

### **2. Замена ввода текста из файлов**

---

Давайте сначала создадим файл, используя следующее.

```powershell
$ echo 'strawberry fields forever...' >> input-file
$ cat input-file
```

Теперь предположим, что мы хотим заменить клубнику черникой. Мы можем сделать это, используя следующую простую команду. Обратите внимание на сходство между частью sed этой команды и приведенной выше.

```powershell
$ sed 's/strawberry/blueberry/' input-file
```

Мы просто добавили имя файла после части sed. Вы также можете сначала вывести содержимое файла, а затем использовать sed для редактирования выходного потока, как показано ниже.

```powershell
$ cat input-file | sed 's/strawberry/blueberry/'
```

### **3. Сохранение изменений в файлах**

---

Как мы уже упоминали, sed вообще не меняет входные данные. Он просто выводит преобразованные данные на стандартный вывод, которым по умолчанию является терминал Linux. Вы можете убедиться в этом, выполнив следующую команду.

```powershell
$ cat input-file
```

Это отобразит исходное содержимое файла. Однако предположим, что вы хотите сделать ваши изменения постоянными. Вы можете сделать это несколькими способами. Стандартный метод — перенаправить вывод sed в другой файл. Следующая команда сохраняет вывод предыдущей команды sed в файл с именем выходной-файл.

```powershell
$ sed 's/strawberry/blueberry/' input-file >> output-file
```

Вы можете убедиться в этом, используя следующую команду.

```powershell
$ cat output-file
```

### **4. Сохранение изменений в исходном файле**

---

Что, если вы хотите сохранить вывод sed обратно в исходный файл? Это можно сделать с помощью параметра **-i** или **-in-place** этого инструмента. Приведенные ниже команды демонстрируют это на соответствующих примерах.

```powershell
$ sed -i 's/strawberry/blueberry' input-file
$ sed --in-place 's/strawberry/blueberry/' input-file
```

Обе эти команды эквивалентны и записывают изменения, внесенные sed, обратно в исходный файл. Однако, если вы думаете о перенаправлении вывода обратно в исходный файл, это не будет работать должным образом.

```powershell
$ sed 's/strawberry/blueberry/' input-file > input-file
```

Эта команда _**не будет работать**_ и приведет к пустому входному файлу. Это связано с тем, что оболочка выполняет перенаправление перед выполнением самой команды.

### **5. Экранирование разделителей**

---

Многие традиционные примеры sed используют символ «/» в качестве разделителя. Однако что, если вы хотите заменить строку, содержащую этот символ? В приведенном ниже примере показано, как заменить путь к имени файла с помощью sed. Нам нужно будет экранировать разделители «/», используя символ обратной косой черты.

```powershell
$ echo '/usr/local/bin/dummy' >> input-file
$ sed 's/\/usr\/local\/bin\/dummy/\/usr\/bin\/dummy/' input-file > output-file
```

Еще один простой способ избежать разделителей — использовать другой метасимвол. Например, мы могли бы использовать «_» вместо «/» в качестве разделителей команды подстановки. Это совершенно справедливо, поскольку sed не требует каких-либо конкретных разделителей. Символ «/» используется по соглашению, а не как требование.

```powershell
$ sed 's_/usr/local/bin/dummy_/usr/bin/dummy/_' input-file
```

### **6. Замена каждого экземпляра строки**

---

Одна интересная особенность команды подстановки заключается в том, что по умолчанию она заменяет только один экземпляр строки в каждой строке.

```powershell
$ cat << EOF >> input-file 
one two one three
two four two
three one four
EOF
```

Эта команда заменит содержимое входного файла некоторыми случайными числами в строковом формате. Теперь посмотрите на команду ниже.

```powershell
$ sed 's/one/ONE/' input-file
```

Как вы должны видеть, эта команда заменяет только первое вхождение «единицы» в первой строке. Вам нужно использовать глобальную замену, чтобы заменить все вхождения слова с помощью sed. Просто добавьте **’g’** после последнего разделителя **‘s**’.

```powershell
$ sed 's/one/ONE/g' input-file
```

Это заменит все вхождения слова «один» во входном потоке.

[![](media/substitute-all-patterns-using-sed-command.jpg.webp)](https://ru.linux-terminal.com/common-images/practical-examples-of-the-sed-command-in-linux/substitute-all-patterns-using-sed-command.jpg)

### **7. Использование совпавшей строки**

Иногда пользователи могут захотеть добавить определенные элементы, например, круглые скобки или кавычки вокруг определенной строки. Это легко сделать, если вы точно знаете, что ищете. Однако что, если мы не знаем точно, что обнаружим? Утилита sed предоставляет небольшую приятную функцию для сопоставления такой строки.

```powershell
$ echo 'one two three 123' | sed 's/123/(123)/'
```

Здесь мы добавляем круглые скобки вокруг числа 123, используя команду подстановки sed. Однако мы можем сделать это для любой строки в нашем входном потоке, используя специальный метасимвол **&**, как показано в следующем примере.

```powershell
$ echo 'one two three 123' | sed 's/[a-z][a-z]*/(&)/g'
```

Эта команда добавит скобки вокруг всех слов в нижнем регистре во входных данных. Если вы опустите опцию **’g’**, sed сделает это только для первого слова, а не для всех.

### **8. Использование расширенных регулярных выражений**

---

В приведенной выше команде мы сопоставили все слова в нижнем регистре, используя регулярное выражение [a-z][a-z]*. Он соответствует одной или нескольким строчным буквам. Другой способ сопоставить их — использовать метасимвол **’+’**. Это пример расширенных регулярных выражений. Таким образом, sed не будет поддерживать их по умолчанию.

```powershell
$ echo 'one two three 123' | sed 's/[a-z]+/(&)/g'
```

Эта команда не работает должным образом, поскольку sed не поддерживает метасимвол **’+’** «из коробки». Вам нужно использовать параметры **-E** или **-r**, чтобы включить расширенные регулярные выражения в sed.

```powershell
$ echo 'one two three 123' | sed -E 's/[a-z]+/(&)/g'
$ echo 'one two three 123' | sed -r 's/[a-z]+/(&)/g'
```

### **9. Выполнение нескольких замен**

---

Мы можем использовать более одной команды sed за один раз, разделяя их **’;’** (точка с запятой). Это очень полезно, поскольку позволяет пользователю создавать более надежные комбинации команд и уменьшать дополнительные хлопоты на лету. Следующая команда показывает нам, как заменить три строки за один раз, используя этот метод.

```powershell
$ echo 'one two three' | sed 's/one/1/; s/two/2/; s/three/3/'
```

Мы использовали этот простой пример, чтобы проиллюстрировать, как выполнять множественные замены или любые другие операции sed.

### **10. Замена без учета регистра**

---

Утилита sed позволяет нам заменять строки без учета регистра. Сначала давайте посмотрим, как sed выполняет следующую простую операцию замены.

```powershell
$ echo 'one ONE OnE' | sed 's/one/1/g' # replaces single one
```

Команда подстановки может сопоставить только один экземпляр «одного» и, таким образом, заменить его. Однако, скажем, мы хотим, чтобы он соответствовал всем вхождениям «единицы», независимо от их регистра. Мы можем решить эту проблему, используя флаг «i» операции подстановки sed.

```powershell
$ echo 'one ONE OnE' | sed 's/one/1/gi' # replaces all ones
```

### **11. Печать определенных строк**

---

Мы можем просмотреть определенную строку из входных данных, используя команду **’p’**. Давайте добавим еще немного текста в наш входной файл и продемонстрируем этот пример.

```powershell
$ echo 'Adding some more
text to input file
for better demonstration' >> input-file
```

Теперь запустите следующую команду, чтобы увидеть, как напечатать определенную строку, используя «p».

```powershell
$ sed '3p; 6p' input-file
```

Вывод должен содержать строки номер три и шесть дважды. Это не то, чего мы ожидали, верно? Это происходит потому, что по умолчанию sed выводит все строки входного потока, а также строки, заданные конкретно. Чтобы напечатать только определенные строки, нам нужно подавить все остальные выходные данные.

```powershell
$ sed -n '3p; 6p' input-file
$ sed --quiet '3p; 6p' input-file
$ sed --silent '3p; 6p' input-file
```

Все эти команды sed эквивалентны и печатают только третью и шестую строки из нашего входного файла. Таким образом, вы можете подавить нежелательный вывод, используя один из параметров **-n**, **-quiet** или **-silent**.

### **12. Печать диапазона линий**

---

Приведенная ниже команда напечатает ряд строк из нашего входного файла. Символ **','** может использоваться для указания диапазона ввода для sed.

```powershell
$ sed -n '2,4p' input-file
$ sed --quiet '2,4p' input-file
$ sed --silent '2,4p' input-file
```

все эти три команды также эквивалентны. Они напечатают вторую-четвертую строки нашего входного файла.

[![](media/print-range-of-lines.jpg)](https://ru.linux-terminal.com/common-images/practical-examples-of-the-sed-command-in-linux/print-range-of-lines.jpg)

### **13. Печать непоследовательных строк**

---

Предположим, вы хотите напечатать определенные строки из вашего текстового ввода с помощью одной команды. Вы можете выполнить такие операции двумя способами. Первый — объединить несколько операций печати с помощью разделителя **’;’**.

```powershell
$ sed -n '1,2p; 5,6p' input-file
```

Эта команда печатает первые две строки входного файла, а затем две последние строки. Вы также можете сделать это, используя опцию **-e** sed. Обратите внимание на различия в синтаксисе.

```powershell
$ sed -n -e '1,2p' -e '5,6p' input-file
```

### **14. Печать каждой N-й строки**

---

Допустим, мы хотим отобразить каждую вторую строку из входного файла. Утилита sed упрощает эту задачу, предоставляя оператор тильды **’~’**. Взгляните на следующую команду, чтобы понять, как это работает.

```powershell
$ sed -n '1~2p' input-file
```

Эта команда работает, печатая первую строку, за которой следует каждая вторая строка ввода. Следующая команда выводит вторую строку, за которой следует каждая третья строка, из вывода простой команды ip.

```powershell
$ ip -4 a | sed -n '2~3p'
```

### **15. Замена текста внутри диапазона**

---

Мы также можем заменить некоторый текст только в пределах указанного диапазона так же, как мы его напечатали. Команда ниже демонстрирует, как заменить «единицы» на «1» в первых трех строках нашего входного файла с помощью sed.

```powershell
$ sed '1,3 s/one/1/gi' input-file
```

Эта команда оставит любую другую единицу без изменений. Добавьте в этот файл несколько строк, содержащих один, и попробуйте проверить это сами.

### **16. Удаление строк из ввода**

---

Команда ed **’d’** позволяет нам удалять определенные строки или диапазон строк из текстового потока или из входных файлов. Следующая команда демонстрирует, как удалить первую строку из вывода sed.

```powershell
$ sed '1d' input-file
```

Поскольку sed записывает только в стандартный вывод, это удаление не отразится на исходном файле. Эту же команду можно использовать для удаления первой строки из многострочного текстового потока.

```powershell
$ ps | sed '1d'
```

Таким образом, просто используя команду **‘d’** после адреса строки, мы можем подавить ввод для sed.

### **17. Удаление диапазона строк из ввода**

---

Также очень легко удалить диапазон строк, используя оператор «,» рядом с опцией **«d»**. Следующая команда sed подавит первые три строки из нашего входного файла.

```powershell
$ sed '1,3d' input-file
```

Мы также можем удалить непоследовательные строки, используя одну из следующих команд.

```powershell
$ sed '1d; 3d; 5d' input-file
```

Эта команда отображает вторую, четвертую и последнюю строку нашего входного файла. Следующая команда опускает некоторые произвольные строки из вывода простой команды Linux ip.

```powershell
$ ip -4 a | sed '1d; 3d; 4d; 6d'
```

### **18. Удаление последней строки**

---

Утилита sed имеет простой механизм, позволяющий удалить последнюю строку из текстового потока или входного файла. Это символ **‘$’**, который, помимо удаления, также может использоваться для других типов операций. Следующая команда удаляет последнюю строку из входного файла.

```powershell
$ sed '$d' input-file
```

Это очень полезно, поскольку часто мы можем знать количество строк заранее. Это работает аналогичным образом для входных данных конвейера.

```powershell
$ seq 3 | sed '$d'
```

### **19. Удаление всех строк, кроме определенных**

---

Еще один удобный пример удаления sed — удалить все строки, кроме тех, которые указаны в команде. Это полезно для фильтрации важной информации из текстовых потоков или вывода других команд терминала Linux.

```powershell
$ free | sed '2!d'
```

Эта команда выведет только использование памяти, которое находится во второй строке. Вы также можете сделать то же самое с входными файлами, как показано ниже.

```powershell
$ sed '1,3!d' input-file
```

Эта команда удаляет из входного файла все строки, кроме первых трех.

### **20. Добавление пустых строк**

---

Иногда входной поток может быть слишком концентрированным. В таких случаях вы можете использовать утилиту sed для добавления пустых строк между входными данными. В следующем примере между каждой строкой вывода команды ps добавляется пустая строка.

```powershell
$ ps aux | sed 'G'
```

Команда **’G’** добавляет эту пустую строку. Вы можете добавить несколько пустых строк, используя более одной команды **‘G’** для sed.

```powershell
$ sed 'G; G' input-file
```

Следующая команда показывает, как добавить пустую строку после определенного номера строки. Он добавит пустую строку после третьей строки нашего входного файла.

```powershell
$ sed '3G' input-file
```

[![](media/add-blank-lines.jpg)](https://ru.linux-terminal.com/common-images/practical-examples-of-the-sed-command-in-linux/add-blank-lines.jpg)

### **21. Замена текста в определенных строках**

---

Утилита sed позволяет пользователям заменять текст в определенной строке. Это полезно в ряде различных сценариев. Допустим, мы хотим заменить слово «один» в третьей строке нашего входного файла. Для этого мы можем использовать следующую команду.

```powershell
$ sed '3 s/one/1/' input-file
```

**’3’** перед началом команды **’s’** указывает, что мы хотим заменить только слово, найденное в третьей строке.

### **22. Замена N-го слова строки**

---

Мы также можем использовать команду sed для замены n-го вхождения шаблона для данной строки. Следующий пример иллюстрирует это на примере одной строки в bash.

```powershell
$ echo 'one one one one one one' | sed 's/one/1/3'
```

Эта команда заменит третью единицу на цифру 1. Это работает так же для входных файлов. Команда ниже заменяет последние «два» из второй строки входного файла.

```powershell
$ cat input-file | sed '2 s/two/2/2'
```

Сначала мы выбираем вторую строку, а затем указываем, какое вхождение шаблона нужно изменить.

### **23. Добавление новых строк**

---

Вы можете легко добавить новые строки во входной поток, используя команду **’a’**. Посмотрите простой пример ниже, чтобы увидеть, как это работает.

```powershell
$ sed 'a new line in input' input-file
```

Приведенная выше команда добавит строку «новая строка во входных данных» после каждой строки исходного входного файла. Однако это может быть не то, что вы хотели. Вы можете добавить новые строки после определенной строки, используя следующий синтаксис.

```powershell
$ sed '3 a new line in input' input-file
```

### **24. Вставка новых строк**

---

Мы также можем вставлять строки вместо их добавления. Команда ниже вставляет новую строку перед каждой строкой ввода.

```powershell
$ seq 5 | sed 'i 888'
```

Команда **’i’** вставляет строку 888 перед каждой строкой вывода seq. Чтобы вставить строку перед определенной строкой ввода, используйте следующий синтаксис.

```powershell
$ seq 5 | sed '3 i 333'
```

Эта команда добавит число 333 перед строкой, которая на самом деле содержит три. Это простые примеры вставки строк. Вы можете легко добавлять строки, сопоставляя строки с помощью шаблонов.

### **25. Изменение строк ввода**

---

Мы также можем изменить строки входного потока напрямую, используя команду **’c’** утилиты sed. Это полезно, когда вы точно знаете, какую строку заменить, и не хотите сопоставлять ее с помощью регулярных выражений. В приведенном ниже примере изменяется третья строка вывода команды seq.

```powershell
$ seq 5 | sed '3 c 123'
```

Он заменяет содержимое третьей строки (3) на число 123. В следующем примере показано, как изменить последнюю строку нашего входного файла с помощью **‘c’**.

```powershell
$ sed '$ c CHANGED STRING' input-file
```

Мы также можем использовать регулярное выражение для выбора номера строки, которую нужно изменить. Следующий пример иллюстрирует это.

```powershell
$ sed '/demo*/ c CHANGED TEXT' input-file
```

### **26. Создание резервных файлов для ввода**

---

Если вы хотите преобразовать текст и сохранить изменения обратно в исходный файл, мы настоятельно рекомендуем вам создать резервные файлы, прежде чем продолжить. Следующая команда выполняет некоторые операции sed с нашим входным файлом и сохраняет его как оригинал. Более того, в качестве меры предосторожности он создает резервную копию с именем input-file.old.

```powershell
$ sed -i.old 's/one/1/g; s/two/2/g; s/three/3/g' input-file
```

Параметр **-i** записывает изменения, внесенные sed, в исходный файл. Часть суффикса .old отвечает за создание документа input-file.old.

### **27. Печать линий на основе шаблонов**

---

Скажем, мы хотим напечатать все строки из входных данных по определенному шаблону. Это довольно просто, если объединить команды sed **‘p’** с опцией **-n**. Следующий пример иллюстрирует это с использованием входного файла.

```powershell
$ sed -n '/^for/ p' input-file
```

Эта команда ищет шаблон «for» в начале каждой строки и печатает только строки, начинающиеся с него. Символ **’^’** — это специальный символ регулярного выражения, известный как якорь. Он указывает, что шаблон должен располагаться в начале строки.

### **28. Использование SED как альтернативы GREP**

---

Команда grep в Linux ищет определенный шаблон в файле и, если он найден, отображает строку. Мы можем эмулировать это поведение с помощью утилиты sed. Следующая команда иллюстрирует это на простом примере.

```powershell
$ sed -n 's/strawberry/&/p' /usr/share/dict/american-english
```

Эта команда находит слово клубника в файле **американско-английского** словаря. Он работает путем поиска шаблона клубника, а затем использует совпадающую строку вместе с командой **‘p’** для ее печати. Флаг **-n** подавляет все остальные строки вывода. Мы можем упростить эту команду, используя следующий синтаксис.

```powershell
$ sed -n '/strawberry/p' /usr/share/dict/american-english
```

[![](media/grep-alternative-using-sed-command.jpg)](https://ru.linux-terminal.com/common-images/practical-examples-of-the-sed-command-in-linux/grep-alternative-using-sed-command.jpg)

### **29. Добавление текста из файлов**

---

Команда **’r’** утилиты sed позволяет нам добавлять текст, прочитанный из файла, во входной поток. Следующая команда генерирует входной поток для sed с помощью команды seq и добавляет к этому потоку тексты, содержащиеся в input-file.

```powershell
$ seq 5 | sed 'r input-file'
```

Эта команда добавит содержимое входного файла после каждой последовательной входной последовательности, созданной seq. Используйте следующую команду, чтобы добавить содержимое после чисел, сгенерированных seq.

```powershell
$ seq 5 | sed '$ r input-file'
```

Вы можете использовать следующую команду, чтобы добавить содержимое после n-й строки ввода.

```powershell
$ seq 5 | sed '3 r input-file'
```

### **30. Запись изменений в файлы**

---

Предположим, у нас есть текстовый файл, содержащий список веб-адресов. Скажем, некоторые из них начинаются с www, некоторые https, третьи http. Мы можем изменить все адреса, начинающиеся с www, на https и сохранить только те, которые были изменены, в совершенно новый файл.

```powershell
$ sed 's/www/https/ w modified-websites' websites
```

Теперь, если вы проверите содержимое файла модифицированных веб-сайтов, вы обнаружите только те адреса, которые были изменены sed. Опция **‘w filename**’ заставляет sed записывать изменения в указанное имя файла. Это полезно, когда вы имеете дело с большими файлами и хотите сохранить измененные данные отдельно.

### **31. Использование программных файлов SED**

---

Иногда вам может потребоваться выполнить несколько операций sed с заданным входным набором. В таких случаях лучше написать программный файл, содержащий все различные sed-скрипты. Затем вы можете просто вызвать этот программный файл, используя опцию **-f** утилиты sed.

```powershell
$ cat << EOF >> sed-script
s/a/A/g
s/e/E/g
s/i/I/g
s/o/O/g
s/u/U/g
EOF
```

Эта программа sed преобразует все строчные гласные в прописные. Вы можете запустить это, используя приведенный ниже синтаксис.

```powershell
$ sed -f sed-script input-file
$ sed --file=sed-script < input-file
```

### **32. Использование многострочных команд SED**

---

Если вы пишете большую программу sed, занимающую несколько строк, вам нужно будет правильно их заключить в кавычки. Синтаксис немного различается в разных оболочках Linux. К счастью, для оболочки Bourne и ее производных (bash) это очень просто.

```powershell
$ sed '
s/a/A/g 
s/e/E/g 
s/i/I/g 
s/o/O/g 
s/u/U/g' < input-file
```

В некоторых оболочках, например в оболочке C (csh), кавычки необходимо защищать с помощью символа обратной косой черты (\).

```powershell
$ sed 's/a/A/g \
s/e/E/g \
s/i/I/g \
s/o/O/g \
s/u/U/g' < input-file
```

### **33. Печать номеров строк**

---

Если вы хотите напечатать номер строки, содержащей определенную строку, вы можете найти ее по шаблону и очень легко распечатать. Для этого вам нужно будет использовать команду **’=’** утилиты sed.

```powershell
$ sed -n '/ion*/ =' < input-file
```

Эта команда будет искать заданный шаблон во входном файле и выводить его номер строки в стандартный вывод. Для решения этой проблемы вы также можете использовать комбинацию grep и awk.

```powershell
$ cat -n input-file | grep 'ion*' | awk '{print $1}'
```

Вы можете использовать следующую команду, чтобы напечатать общее количество строк во входных данных.

```powershell
$ sed -n '$=' input-file
```

### **34. Предотвращение перезаписи символических ссылок**

---

Команда sed **'i'** или **'-in-place**' часто перезаписывает любые системные ссылки обычными файлами. Во многих случаях это нежелательная ситуация, поэтому пользователи могут захотеть предотвратить это. К счастью, sed предоставляет простой параметр командной строки, позволяющий отключить перезапись символических ссылок.

```powershell
$ echo 'apple' > fruit
$ ln --symbolic fruit fruit-link
$ sed --in-place --follow-symlinks 's/apple/banana/' fruit-link
$ cat fruit
```

Таким образом, вы можете предотвратить перезапись символических ссылок, используя параметр **-follow-symlinks** утилиты sed. Таким образом, вы можете сохранить символические ссылки при обработке текста.

### **35. Печать всех имен пользователей из /etc/passwd**

---

Файл _/etc/passwd_ содержит общесистемную информацию для всех учетных записей пользователей Linux. Мы можем получить список всех имен пользователей, доступных в этом файле, с помощью простой однострочной программы sed. Внимательно посмотрите на приведенный ниже пример, чтобы увидеть, как это работает.

```powershell
$ sed 's/\([^:]*\).*/\1/' /etc/passwd
```

Мы использовали шаблон регулярного выражения, чтобы получить первое поле из этого файла, отбросив всю остальную информацию. Здесь хранятся имена пользователей в файле _/etc/passwd_.

### **36. Удаление строк с комментариями из ввода**

---

Многие системные инструменты, а также сторонние приложения поставляются с файлами конфигурации. Эти файлы обычно содержат множество комментариев, подробно описывающих параметры. Однако иногда вам может потребоваться отображать только параметры конфигурации, сохраняя при этом исходные комментарии.

```powershell
$ cat ~/.bashrc | sed -e 's/#.*//;/^$/d'
```

Эта команда удаляет закомментированные строки из файла конфигурации bash. Комментарии отмечаются предшествующим знаком «#». Итак, мы удалили все такие строки, используя простой шаблон регулярного выражения. Если комментарии отмечены другим символом, замените «#» в приведенном выше шаблоне этим конкретным символом.

```powershell
$ cat ~/.vimrc | sed -e 's/".*//;/^$/d'
```

Это приведет к удалению комментариев из файла конфигурации vim, который начинается с символа двойной кавычки («).

[![](media/delete-comments.jpg)](https://ru.linux-terminal.com/common-images/practical-examples-of-the-sed-command-in-linux/delete-comments.jpg)

### **37. Удаление пробелов из ввода**

---

Многие текстовые документы заполнены ненужными пробелами. Зачастую они являются результатом плохого форматирования и могут испортить весь документ. К счастью, sed позволяет пользователям довольно легко удалить эти нежелательные пробелы. Вы можете использовать следующую команду, чтобы удалить ведущие пробелы из входного потока.

```powershell
$ sed 's/^[ \t]*//' whitespace.txt
```

Эта команда удалит все ведущие пробелы из файла whitespace.txt. Если вы хотите удалить конечные пробелы, используйте вместо этого следующую команду.

```powershell
$ sed 's/[ \t]*$//' whitespace.txt
```

Вы также можете использовать команду sed для одновременного удаления начальных и конечных пробелов. Приведенную ниже команду можно использовать для выполнения этой задачи.

```powershell
$ sed 's/^[ \t]*//;s/[ \t]*$//' whitespace.txt
```

### **38. Создание смещений страниц с помощью SED**

---

Если у вас большой файл с нулевыми передними отступами, вы можете создать для него некоторые смещения страниц. Смещения страниц — это просто ведущие пробелы, которые помогают нам легко читать строки ввода. Следующая команда создает смещение в 5 пробелов.

```powershell
$ sed 's/^/ /' input-file
```

Просто увеличьте или уменьшите интервал, чтобы указать другое смещение. Следующая команда уменьшает смещение страницы до 3 пустых строк.

```powershell
$ sed 's/^/ /' input-file
```

### **39. Изменение местами строк ввода**

---

Следующая команда показывает нам, как использовать sed для изменения порядка строк во входном файле. Он эмулирует поведение команды Linux **tac**.

```powershell
$ sed '1!G;h;$!d' input-file
```

Эта команда меняет местами строки документа входной строки. Это также можно сделать альтернативным методом.

```powershell
$ sed -n '1!G;h;$p' input-file
```

### **40. Изменение местами ввода символов**

---

Мы также можем использовать утилиту sed для изменения местами символов во входных строках. Это изменит порядок каждого последовательного символа во входном потоке.

```powershell
$ sed '/\n/!G;s/\(.\)\(.*\n\)/&\2\1/;//D;s/.//' input-file
```

Эта команда эмулирует поведение команды Linux **rev**. Вы можете убедиться в этом, выполнив приведенную ниже команду после приведенной выше.

```powershell
$ rev input-file
```

### **41. Соединение пар строк ввода**

---

Следующая простая команда sed объединяет две последовательные строки входного файла в одну строку. Это полезно, если у вас большой текст, содержащий разделенные линии.

```powershell
$ sed '$!N;s/\n/ /' input-file
$ tail -15 /usr/share/dict/american-english | sed '$!N;s/\n/ /'
```

Это полезно в ряде задач по манипулированию текстом.

### **42. Добавление пустых строк в каждую N-ю строку ввода**

---

Вы можете легко добавить пустую строку в каждую n-ю строку входного файла, используя sed. Следующие команды добавляют пустую строку в каждую третью строку входного файла.

```powershell
$ sed 'n;n;G;' input-file
```

Используйте следующее, чтобы добавить пустую строку в каждую вторую строку.

```powershell
$ sed 'n;G;' input-file
```

### **43. Печать последних N-х строк**

---

Ранее мы использовали команды sed для печати строк ввода на основе номера строки, диапазона и шаблона. Мы также можем использовать sed для эмуляции поведения команд head или Tail. В следующем примере печатаются последние 3 строки входного файла.

```powershell
$ sed -e :a -e '$q;N;4,$D;ba' input-file
```

Она аналогична приведенной ниже команде Tail tail -3 input-file.

### **44. Печать строк, содержащих определенное количество символов**

---

Печатать строки на основе количества символов очень легко. Следующая простая команда выведет строки, содержащие 15 или более символов.

```powershell
$ sed -n '/^.\{15\}/p' input-file
```

Используйте приведенную ниже команду для печати строк длиной менее 20 символов.

```powershell
$ sed -n '/^.\{20\}/!p' input-file
```

Мы также можем сделать это более простым способом, используя следующий метод.

```powershell
$ sed '/^.\{20\}/d' input-file
```

[![](media/print-lines-based-on-characters.jpg)](https://ru.linux-terminal.com/common-images/practical-examples-of-the-sed-command-in-linux/print-lines-based-on-characters.jpg)

### **45. Удаление повторяющихся строк**

---

В следующем примере sed показано, как эмулировать поведение команды Linux **uniq**. Он удаляет из ввода любые две последовательные повторяющиеся строки.

```powershell
$ sed '$!N; /^\(.*\)\n\1$/!P; D' input-file
```

Однако sed не может удалить все повторяющиеся строки, если входные данные не отсортированы. Хотя вы можете отсортировать текст с помощью команды sort, а затем подключить вывод к sed с помощью канала, это изменит ориентацию строк.

### **46. Удаление всех пустых строк**

---

Если ваш текстовый файл содержит много ненужных пустых строк, вы можете удалить их с помощью утилиты sed. Команда ниже демонстрирует это.

```powershell
$ sed '/^$/d' input-file
$ sed '/./!d' input-file
```

Обе эти команды удалят все пустые строки, присутствующие в указанном файле.

### **47. Удаление последних строк абзацев**

---

Вы можете удалить последнюю строку всех абзацев, используя следующую команду sed. В этом примере мы будем использовать фиктивное имя файла. Замените это именем фактического файла, содержащего несколько абзацев.

```powershell
$ sed -n '/^$/{p;h;};/./{x;/./p;}' paragraphs.txt
```

### **48. Отображение страницы справки**

---

Страница справки содержит обобщенную информацию обо всех доступных опциях и использовании программы sed. Вы можете вызвать это, используя следующий синтаксис.

```powershell
$ sed -h
$ sed --help
```

Вы можете использовать любую из этих двух команд, чтобы найти красивый и компактный обзор утилиты sed.

### **49. Отображение страницы руководства**

---

На странице руководства представлено подробное обсуждение sed, его использования и всех доступных опций. Вам следует внимательно прочитать это, чтобы четко понять sed.

```powershell
$ man sed
```

### **50. Отображение информации о версии**

---

Опция **-version** sed позволяет нам просмотреть, какая версия sed установлена на нашем компьютере. Это полезно при отладке ошибок и сообщении об ошибках.

```powershell
$ sed --version
```

Приведенная выше команда отобразит информацию о версии утилиты sed в вашей системе.

## **Завершение мыслей**

---

Команда sed — один из наиболее широко используемых инструментов для работы с текстом, предоставляемых дистрибутивами Linux. Это одна из трех основных утилит фильтрации в Unix, наряду с grep и awk. Мы выделили 50 простых, но полезных примеров, которые помогут читателям начать работу с этим замечательным инструментом. Мы настоятельно рекомендуем пользователям попробовать эти команды самостоятельно, чтобы получить практическую информацию. Кроме того, попробуйте изменить примеры, приведенные в этом руководстве, и исследуйте их эффект. Это поможет вам быстро освоить sed. Надеюсь, вы ясно изучили основы sed. Не забудьте оставить комментарий ниже, если у вас есть вопросы.

#### Источник
1. [https://ru.linux-terminal.com/?p=472](https://ru.linux-terminal.com/?p=472)