[ffmpeg](https://ffmpeg.org/) - это утилита командной строки (CLI) для обработки мультимедийных файлов. Это фреймворк с множеством функций и, благодаря лицензии с открытым исходным кодом, является основой для многих распространенных приложений, таких как **VLC**, **YouTube**, **iTunes** и многих других. Ряд видеоредакторов для Linux используют ffmpeg под GUI.

В этом руководстве мы расскажем, как установить ffmpeg, и как использовать его базовые и продвинутые функции.

---

### Установка ffmpeg в Linux

Установка ffmpeg - это простой процесс. Это популярное приложение, которое доступно в большинстве дистрибутивов Linux через менеджер пакетов.

#### Установка ffmpeg в Ubuntu

В **Ubuntu** ffmpeg доступен в репозитории **Universe** , поэтому убедитесь, что он включен. а затем обновите список пакетов и установите ffmpeg. Вы можете сделать все это, используя следующие команды в терминале:

```bash
sudo add-apt-repository universe
sudo apt update
sudo apt install ffmpeg
```

Готово! Чтобы проверить установку выполните:

ffmpeg

Вы должны увидеть вывод, описывающий вашу конфигурацию ffmpeg, включая версию.

![[Разное/mediainfo/ffmpeg_images/2c1d2e8120a8d946f43039075113a27e_MD5.png]]

Как вы можете видеть на скриншоте выше, установлена версия 3.4.4. Однако [последняя версия](http://ffmpeg.org/download.html) ffmpeg на момент написания этой статьи - 4.2. Чтобы установить любую версию 4.x, вы должны установить ffmpeg через **PPA** (персональный архив пакетов).

Существует неофициальный PPA, который вы можете использовать для установки последней версии ffmpeg. Просто используйте эти команды:

```bash
sudo add-apt-repository ppa:jonathonf/ffmpeg-4
sudo apt update
sudo apt install ffmpeg -y
```

#### Установка ffmpeg в дистрибутивах на основе Arch

Чтобы установить ffmpeg в дистрибутивах на основе Arch, используйте следующую команду:

```bash
sudo pacman -S ffmpeg
```

#### Установка ffmpeg в дистрибутивах на основе Fedora

Чтобы установить ffmpeg в дистрибутивы Linux на основе Fedora, вы можете использовать эту команду:

```bash
sudo dnf install ffmpeg
```

#### Установка ffmpeg в CentOS/RHEL

FFmpeg недоступен в репозиториях CentOS 8 по умолчанию. Вы можете собрать инструменты **ffmpeg** из исходного кода или установить его с помощью утилиты `dnf` из репозитория **Negativo17**.

Репозиторий **Negativo17** зависит от репозиториев **EPEL** (Extra Packages for Enterprise Linux) и **PowerTools**. Для их включения используйте:

```bash
sudo dnf install epel-release
sudo yum config-manager --set-enabled PowerTools
sudo yum-config-manager --add-repo=https://negativo17.org/repos/epel-multimedia.repo
```

После включения этих репозиториев уже можно установить сам **ffmpeg**:

```bash
sudo dnf install ffmpeg
```

#### Установка ffmpeg в Debian

Официальные репозитории Debian содержат пакеты FFmpeg, которые можно установить с помощью менеджера пакетов `apt`.

```bash
sudo apt install ffmpeg
```

---

### Как использовать ffmpeg: Основы

С установленным **ffmpeg** перейдем к основным командам, чтобы вы начали использовать этот мощный инструмент.

Основные строительные блоки **ffmpeg**:

- **ffmpeg** - инструмент командной строки для конвертации мультимедийных файлов между форматами
- **ffplay** - простой медиаплеер на основе SDL и библиотек FFmpeg
- **ffprobe** - простой мультимедийный анализатор потоков

**ffmpeg** также содержит библиотеки для разработчиков - `libavutil`, `libavcodec`, `libavformat`, `libavdevice`, `libavfilter`, `libswscale` и `libswresample`.

Процесс транскодирования в ffmpeg для может быть описан следующей схемой:

![[Разное/mediainfo/ffmpeg_images/32afc7358a1f079fc0d2c41c43a87530_MD5.png]]

#### 0. Команды ffmpeg

Основная форма команды **ffmpeg**:

```bash
ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...
```

Вы должны иметь в виду, что все параметры файла применяются только к файлу, который следует за ними (и вы должны будете записать их снова для следующего файла).

Любой файл, которому не предшествует `-i`, считается выходным файлом. **ffmpeg** использует столько входов и выходов, сколько вы предоставляете. Вы также можете использовать одно и то же имя как для входного, так и для выходного файла, но вам придется добавить тег `-y` перед именем выходного файла.

> Вы не должны смешивать входы и выходы: сначала укажите входные файлы, затем укажите выходные файлы.

#### 1. Получить информацию медиа файла

Первое использование **ffmpeg** - отображение информации о медиафайле. Это можно сделать, не вводя никаких выходных файлов. Просто введите:

```bash
ffmpeg -i file_name
```

Это работает для аудио и видео файлов:

```bash
ffmpeg -i video_file.mp4
ffmpeg -i audio_file.mp3
```

![[Разное/mediainfo/ffmpeg_images/8d05abbb4e502f1d334eace2d8291e0b_MD5.png]]

Хотя эта команда полезна, она отображает слишком много информации, которая не относится к вашему файлу (информация о ffmpeg). Чтобы пропустить это, добавьте флаг `-hide_banner`:

```bash
ffmpeg -i video_file.mp4 -hide_banner
ffmpeg -i audio_file.mp3 -hide_banner
```

![[Разное/mediainfo/ffmpeg_images/f51b44bcaf229218847c46d931ddac8c_MD5.png]]

Как вы можете видеть, команда теперь выводит только информацию, касающуюся указанного вами медиа-файла (кодировщик, потоки и так далее).

#### 2. Конвертировать медиа файлы

Еще один очень полезный способ использования **ffmpeg** - это беспроблемное преобразование между различными форматами мультимедиа. Вам нужно только указать входные и выходные файлы, так как **ffmpeg** получит требуемый формат из расширений файлов. Это работает для преобразования видео в видео и аудио в аудио.

Вот некоторые примеры:

```bash
ffmpeg -i video_input.mp4 video_output.avi
ffmpeg -i video_input.webm video_output.flv
ffmpeg -i audio_input.mp3 audio_output.ogg
ffmpeg -i audio_input.wav audio_output.flac
```

Вы даже можете указать больше выходных файлов:

```bash
ffmpeg -i audio_input.wav audio_output_1.mp3 audio_output_2.ogg
```

Это преобразует входные файлы во все указанные форматы.

Чтобы увидеть список всех поддерживаемых форматов, используйте:

```bash
ffmpeg -formats
```

Опять же, вы можете добавить `-hide_banner`, чтобы опустить информацию о приложении.

Вы можете указать параметр `-qscale 0` перед выходным файлом, чтобы сохранить качество видеофайла:

```bash
ffmpeg -i video_input.wav -qscale 0 video_output.mp4
```

Кроме того, вы можете указать кодеки, которые вы хотите использовать, добавив `-c:a` (для аудио) и `-c:v` (для видео) с последующим названием кодеков, или скопировать, если хотите использовать те же кодеки, что и оригинальный файл:

```bash
ffmpeg -i video_input.mp4 -c:v copy -c:a libvorbis video_output.avi
```

#### 3. Извлечение аудио из видео

Чтобы извлечь аудио из видеофайла, вы делаете простое преобразование и добавляете флаг `-vn`:

```bash
ffmpeg -i video.mp4 -vn audio.mp3
```

Обратите внимание, что эта команда будет использовать битрейт (скорость передачи) исходного файла. Вы можете установить его вручную, и для этого использовать `-ab` (audio bit rate):

```bash
ffmpeg -i video.mp4 -vn -ab 128k audio.mp3
```

Некоторые распространенные битрейты: **96 КБ**, **128 КБ**, **192 КБ**, **256 КБ**, **320 КБ** (максимальный битрейт, поддерживаемый **mp3**). Другими общими параметрами являются `-ar` (частота звука: **22050**, **441000**, **48000**), `-ac` (количество аудиоканалов), `-f` (формат аудио, хотя обычно определяется автоматически). `-ab` также можно заменить на -`b:a`. Например:

```bash
ffmpeg -i video.mov -vn -ar 44100 -ac 2 -b:a 128k -f mp3 audio.mp3
```

#### 4. Отключение звука в видео

Как и в последнем примере, для этого мы добавим простой тег: `-an` (вместо `-vn`).

```bash
ffmpeg -i video_input.mp4 -an -video_output.mp4
```

> Примечание: Тег `-an` сделает все параметры звука для этого выходного файла бесполезными, поскольку в результате операции не будет звука.

#### 5. Извлечение изображений из видео

Допустим, у вас есть серия изображений (например, слайд-шоу), и вы хотите получить все изображения из этого. Просто введите:

```bash
ffmpeg -i video.mp4 -r 1 -f image2 image-%3d.png
```

`-r` указывает частоту кадров (сколько кадров извлекается в изображения за одну секунду, по умолчанию: 25), `-f` указывает формат вывода.

Последний параметр (выходной файл) имеет несколько интересное название: в конце он использует `%3d`. Это просто нумерует ваши изображения с 3 цифрами (000, 001 и так далее). Вы также можете использовать `%2d` (двухзначный формат) или даже `%4d` (четырехзначный формат), если хотите.

#### 6. Изменение разрешения видео или соотношения сторон

Еще одно простое задание для **ffmpeg**. Все, что вам нужно сделать, чтобы изменить размер видео, это указать новое разрешение после флага `-s`:

```bash
ffmpeg -i video_input.mov -s 1024x576 video_output.mp4
```

Кроме того, вы можете указать `-c:a,` чтобы убедиться в правильности аудиокодеков выходного файла:

```bash
ffmpeg -i video_input.h264 -s 640x480 -c:a video_output.mov
```

Вы также можете изменить соотношение сторон, используя `-aspect`:

```bash
ffmpeg -i video_input.mp4 -aspect 4:3 video_output.mp4
```

#### 7. Добавить изображение обложки в аудио

Это отличный способ превратить аудио в видео, используя одну фотографию (например, обложку альбома) для аудио. Это очень полезная функция, когда вы хотите загружать аудиофайлы на сайты, на которых не разрешено ничего, кроме видео и изображений (YouTube и Facebook являются примерами таких сайтов).

Вот пример:

```bash
ffmpeg -loop 1 -i image.jpg -i audio.wav -c:v libx264 -c:a aac -strict experimental -b:a 192k -shortest output.mp4
```

Просто измените кодеки (`-c:v` указывает видеокодеки, `-c:a` указывает аудиокодеки) и имена ваших файлов. Также вам не нужно использовать `-strict experimental`, если вы используете более новую версию (4.x).

#### 8. Добавить субтитры к видео

С **ffmpeg** просто добавить субтитры к видео. Введите следующее:

```bash
ffmpeg -i video.mp4 -i subtitles.srt -c:v copy -c:a copy -preset veryfast -c:s mov_text -map 0 -map 1 output.mp4
```

Конечно, вы можете указать любые кодеки, которые вы хотите (и любые другие дополнительные параметры, связанные с аудио и видео).

#### 9. Сжатие медиа-файлов

Сжатие файлов значительно уменьшает размер файла, экономя вам много места. Это может быть важно для передачи файлов. С **ffmpeg** есть несколько способов уменьшить размер файла.

> Примечание: Слишком большое сжатие файлов заметно ухудшит качество получаемого файла.

Прежде всего, для аудиофайлов просто уменьшите битрейт (используя `-b:a` или `-ab`):

```bash
ffmpeg -i audio_input.mp3 -ab 128k audio_output.mp3
ffmpeg -i audio_input.mp3 -b:a 192k audio_output.mp3
```

Опять же, некоторые значения битрейта: `96k`, `112k`, `128k`, `160k`, `192k`, `256k`, `320k`. Чем выше битрейт, тем выше размер файла и качество.

Для видео файлов у вас есть больше вариантов. Один из способов - уменьшить битрейт видео (используя `-b:v`):

```bash
ffmpeg -i video_input.mp4 -b:v 1000k -bufsize 1000k video_output.mp4
```

Вы можете установить флаг `-crf` (Constant Rate Factor - коэффициент постоянной скорости). Чем ниже **CRF**, тем выше скорость передачи данных. Также помогает использование **libx264** в качестве видеокодека. Вот очень эффективное уменьшение размера с очень небольшим снижением качества:

```bash
ffmpeg -i video_input.mp4 -c:v libx264 -crf 28 video_output.mp4
```

CRF от 20 до 30 распространен, но можно выставлять и другие значения.

Снижение частоты кадров (фреймрейта) может работать в некоторых случаях (хотя это может очень легко сделать видео медленным):

```bash
ffmpeg -i video_input.mp4 -r 24 video_output.mp4
```

`-r` указывает частоту кадров (в данном случае 24).

Вы также можете попробовать уменьшить разрешение видео (смотри выше как это сделать). Дополнительным советом является сжатие звука, делая его стереофоническим и снижая скорость передачи данных. Например:

```bash
ffmpeg -i video_input.mp4 -c:v libx264 -ac 2 -c:a aac -strict -2 -b:a 128k -crf 28 video_output.mp4
```

> Примечание: `-strict -2` и `-ac 2` позаботятся о стерео части

#### 10. Обрезать медиа файлы

Чтобы обрезать файлы с самого начала, вы должны указать продолжительность, используя `-t`:

```bash
ffmpeg -i input_video.mp4 -t 5 output_video.mp4
ffmpeg -i input_audio.wav -t 00:00:05 output_audio.wav
```

Как видите, это работает как для видео, так и для аудио файлов. Обе команды выше делают одно и то же: сохраняют первые 5 секунд входного файла в выходной файл. Можно использовать различные способы ввода длительности, как видно в примере - одно число (количество секунд) и ЧЧ:ММ:СС (часы, минуты, секунды).

Вы можете пойти еще дальше, указав время начала с `-ss` и даже время окончания с `-to`:

```bash
ffmpeg -i input_audio.mp3 -ss 00:01:14 output_audio.mp3
ffmpeg -i input_audio.wav -ss 00:00:30 -t 10 output_audio.wav
ffmpeg -i input_video.h264 -ss 00:01:30 -to 00:01:40 output_video.h264
ffmpeg -i input_audio.ogg -ss 5 output_audio.ogg
```

Вы можете тут видеть время начала `-ss` (ЧЧ:ММ:СС), длительность `-t` в секундах, время окончания `-to` (ЧЧ:ММ:СС) и время начала `-s` (начать после указанного времени в секундах).

---

### Как использовать ffmpeg: Расширенное использование

Теперь мы расскажем о чуть более продвинутых функциях, таких как запись экрана, использование устройств и другие.

#### 1. Обрезка медиа-файлов

Чтобы разделить файл на несколько частей, нужно указать несколько разделений (указать время начала, время окончания или продолжительность перед каждым выходным файлом).

Посмотрите на этот пример:

```bash
ffmpeg -i video.mp4 -t 00:00:30 video_1.mp4 -ss 00:00:30 video_2.mp4
```

Синтаксис довольно прост. Мы указали `-t` 00:00:30 как продолжительность для первой части (первая часть будет состоять из первых 30 секунд исходного видео). Далее мы указали, что мы хотели бы, чтобы остальные были частью второго видео (начиная с конца последней части, 00:00:30).

Это можно сделать для любого количества частей. Имейте в виду, что это работает со звуком тоже.

#### 2. Склейка медиа-файлов

ffmpeg также может выполнить противоположный процесс: собрать несколько частей вместе.

Для этого вам нужно будет создать новый текстовый файл и начать редактировать его, используя предпочитаемый вами редактор. В примере мы будем использовать **touch** и [](https://wiki.merionet.ru/servernye-resheniya/5/kak-polzovatsya-vim-v-linux/)>vim. Неважно, как вы называете этот файл. Например, назовем его `join.txt` и создадим, используя `touch`:

```bash
touch videos_to_join.txt
```

Теперь отредактируем его в vim

```bash
vim videos_to_join.txt
```

Здесь введите полные пути ко всем файлам, которые вы хотите присоединить (они будут объединены в том порядке, в котором вы их здесь пишете), по одному на строку. Убедитесь, что они имеют одинаковое расширение (например, mp4). Вот пример:

/home/ubuntu/Desktop/video_1.mp4
/home/ubuntu/Desktop/video_2.mp4
/home/ubuntu/Desktop/video_3.mp4

Сохраните файл, который вы только что отредактировали. Этот метод работает для любых аудио или видео файлов.

Теперь введите следующее:

```bash
ffmpeg -f concat -i join.txt output.mp4
```

> Примечание: наш выходной файл - output.mp4, потому что все наши входные файлы имеют расширение mp4.

Это должно объединить все файлы, которые мы записали в `join.txt`, в один выходной файл.

#### 3. Соедините изображения в видео

Таким образом вы можете создать слайдшоу или что-то подобное.

Первое, что мы рекомендуем сделать, это убедиться, что фотографии, которые вы хотите собрать, находятся в одном каталоге. Мы поместим наши в папку `my_photos`. Для картинок рекомендуются расширения `.png` и `.jpg`. Какой бы вариант вы ни выбрали, убедитесь, что все изображения имеют одинаковое расширение.

Формат `-f` нашего преобразования должен быть `image2pipe`. Для ввода необходимо указать дефис `-`. `image2pipe` позволяет вам пайпировать (pipe), используя `|`, результаты команды, такой как `cat`, в `ffmpeg` вместо того, чтобы вводить все имена одно за другим. Чтобы это работало, мы также должны упомянуть, что мы хотим, чтобы видеокодеки были скопированы `-c:v copy` (чтобы правильно использовать изображения):

```bash
cat my_photos/\* | ffmpeg -f image2pipe -i - -c:v copy video.mkv
```

Если вы воспроизводите этот файл, вы можете подумать, что в слайд-шоу были добавлены только некоторые изображения. На самом деле все ваши фотографии были добавлены, но ffmpeg проходит по ним их как можно быстрее. Это означает 1 кадр на фотографию, ffmpeg по умолчанию работает со скоростью около 23 кадров в секунду.

Чтобы изменить это, вам нужно указать желаемую частоту кадров `-framerate`:

```bash
cat my_photos/\* | ffmpeg -framerate 1 -f image2pipe -i - -c:v copy video.mkv
```

В нашем примере мы устанавливаем частоту кадров равную 1, что означает, что каждый кадр (что также означает каждое изображение) появляется в течение 1 секунды.

Чтобы добавить аудио, например, фоновую песню, нам нужно указать аудиофайл в качестве входного файла `-i audo_file` и скопировать аудиокодеки `-c: copy`. Для кодеков вы можете копировать аудио и видео кодеки одновременно с `-c copy`. Убедитесь, что вы установили кодеки прямо перед указанием выходного файла. Вы также можете установить частоту кадров, чтобы все ваши изображения синхронизировались с продолжительностью звука, который вы хотите использовать. Чтобы сделать это, разделите количество изображений на продолжительность аудио (в секундах). Для нашего примера у нас есть аудиофайл длиной 22 секунды и 9 изображений. 9 разделить на 22 составляет приблизительно 0,40, поэтому мы будем использовать это для нашей частоты кадров:

```bash
cat my_photos/\* | ffmpeg -framerate 0.40 -f image2pipe -i - -i audio.wav -c copy video.mkv
```

#### 4. Запись экрана

Тут нужно использовать формат `-f x11grab`. Это запишет ваш **XSERVER**. В качестве входных данных вы должны будете указать номер вашего экрана (основной экран обычно должен быть `0:0`). Но это будет захватывать только верхнюю левую часть экрана. Вы должны добавить размер экрана (или экранов). Наш размер - 1920?1080. Размер экрана должен быть указан перед вводом:

```bash
ffmpeg -f x11grab -s 1920x1080 -i :0.0 output.mp4
```

Нажмите `q` или `CTRL + C` в любое время, чтобы остановить запись.

Вы можете сделать размер выходного файла полноэкранным, введя следующее для размера (вместо 1920?1080 или любого другого установленного разрешения):

-s $(xdpyinfo | grep dimensions | awk '{print $2;}')

Полная команда:

```bash
ffmpeg -f x11grab -s $(xdpyinfo | grep dimensions | awk '{print $2;}') -i :0.0 output.mp4
```

#### 5. Запишите свою веб-камеру

Запись ввода с вашей веб-камеры (или другого устройства, такого как USB-камера) еще проще. В Linux устройства хранятся в `/dev` как `/dev/video0`, `/dev/video1` и так далее:

```bash
ffmpeg -i /dev/video0 output.mkv
```

И также нажмите `q` или `CTRL + C`, чтобы остановить запись.

#### 6. Запишите ваше аудио

Linux обрабатывает аудио в основном через ALSA и pulseaudio. ffmpeg может записывать оба, но мы рассмотрим pulseaudio, так как дистрибутивы на основе Debian включают его по умолчанию. Синтаксис немного отличается для двух методов.

Для pulseaudio, вы должны использовать **force** `-f alsa` и указать устройство ввода по умолчанию как input `-i default`:

```bash
ffmpeg -f alsa -i default output.mp3
```

В настройках звука у дистрибутива убедитесь, что записывающим устройством по умолчанию является то устройство, которое вы хотите записать.

Конечно, для любого типа записи вы также можете указать кодеки. Вы можете выбрать конкретную частоту кадров `-r`. Вы также можете совмещать запись звука с записью с веб-камеры/экрана.

```bash
ffmpeg -i /dev/video0 -f alsa -i default -c:v libx264 -c:a flac -r 30 output.mkv
```

Вместо записи звука вы можете так же легко добавить аудиофайл в качестве звука поверх для записи экрана или веб-камеры:

```bash
ffmpeg -f x11grab -s $(xdpyinfo | grep dimensions | awk '{print $2;}') -i :0.0 -i audio.wav -c:a copy output.mp4
```

> Записи в ffmpeg мелкими, поэтому очень маленькая запись может не сохраниться. Мы рекомендуем сделать запись немного дольше и затем обрезать ее (если вам нужно всего несколько секунд), просто чтобы убедиться, что файл действительно будет записан на ваш диск.

---

### Основное использование фильтров в ffmpeg

Фильтры являются невероятно мощной функцией ffmpeg. Вам доступно огромное количество фильтров, что делает ffmpeg полностью способным обрабатывать любые потребности редактирования.

Основная структура для использования фильтра:

```bash
ffmpeg -i input.mp4 -vf "filter=setting_1=value_1:setting_2=value_2" output.mp4
ffmpeg -i input.wav -af "filter=setting_1=value_1:setting_2=value_2" output.wav
```

Как вы можете видеть, мы указываем видео фильтры `-vf`, (сокращенно от `-filter:v`) и аудио фильтры `-af`, (сокращенно от `-filter:a`). Фактические фильтры пишутся в двойных кавычках `"` и могут быть объединены в цепочку через запятую `,`. Вы можете указать столько фильтров, сколько хотите.

Общая форма фильтра:

filter=setting_2=value_2:setting_2=value_2

Различные настройки фильтра и их значения разделены двоеточиями. Вы также можете выполнять математические операции в качестве значений для различных настроек.

> Более подробное описание различных констант, используемых в выражениях, и различных настроек можно найти в [официальной документации](https://ffmpeg.org/ffmpeg-filters.html) фильтра ffmpeg.

#### 1. Масштабирование видео

Это очень простой фильтр. Единственными настройками являются ширина `w` и высота `h`:

```bash
ffmpeg -i input.mp4 -vf "scale=w=800:h=600" output.mp4
```

Как мы уже упоминали, вы можете использовать математические операции для значений:

```bash
ffmpeg -i input.mkv -vf "scale=w=1/2*in_w:h=1/2*in_h" output.mkv
```

Эта команда устанавливает размер вывода равным половине (1/2) от размера ввода `in_w`, `in_h`.

### 2. Обрезка видео

Что касается фильтра масштабирования, настройки - это ширина и высота результирующего файла. При желании вы можете указать координаты для верхнего левого угла разреза (по умолчанию: центр входного видео):

```bash
ffmpeg -i input.mp4 -vf "crop=w=1280:h=720:x=0:y=0" output.mp4
ffmpeg -i input.mkv -vf "crop=w=400:h=400" output.mkv
```

Как уже отмечалось, вторая обрезка будет вырезать в центре входного файла (так как мы не указали координаты `x` и `y` для верхнего левого угла). Первая команда будет вырезать из левого верхнего угла `x=0:y=0`.

Вот пример, который использует математические выражения в качестве значений:

```bash
ffmpeg -i input.mkv -vf "crop=w=3/4*in_w:h=3/4*in_h" output.mkv
```

Эта команда устанавливает размер вывода на 3/4 от размера ввода (`in_w`, `in_h`).

### 3. Поворот видео

Вы также можете повернуть видео по часовой стрелке на определенную величину в радианах. Чтобы упростить задачу, вы можете указать значение в градусах и преобразовать его в радианы, умножив это значение на `PI/180`:

```bash
ffmpeg -i input.avi -vf "rotate=90\*PI/180"
ffmpeg -i input.mp4 -vf "rotate=PI"
```

Первая команда повернет видео по часовой стрелке на 90 градусов. Вторая команда перевернет видео вверх ногами (PI рад = 180 градусов).

#### 4. Преобразование аудиоканала

Это может быть полезно, если вы каким-то образом получаете звук только в правом ухе или что-то подобное. Вы можете сделать звук слышимым из обоих ушей (в данном конкретном случае) следующим образом:

```bash
ffmpeg -i input.mp3 -af "channelmap=1-0|1-1" output.mp3
```

Это мапит правый `1` аудиоканал на левый `0` и правый `1` аудиоканалы (левое число представляет собой вход, правое число представляет собой выход).

#### 5. Увеличение громкости звука

Вы можете умножить громкость звука на любое действительное число. Вам нужно только указать множитель:

```bash
ffmpeg -i input.wav -af "volume=1.5" output.wav
ffmpeg -i input.ogg -af "volume=0.75" output.ogg
```

Первая команда увеличивает громкость в 1,5 раза. Вторая команда делает звук в 1/4 (0,25) раза тише.

#### 6. Настройка скорости воспроизведения

Фильтр для видео - `setpts` (PTS = presentation time stamp). Поскольку мы на самом деле модифицируем PTS, больший коэффициент означает более медленный результат, и наоборот:

```bash
ffmpeg -i input.mkv -vf "setpts=0.5*PTS" output.mkv
ffmpeg -i input.mp4 -vf "setpts=2*PTS" output.mp4
```

Первая команда удваивает скорость воспроизведения, а вторая команда замедляет видео до 1/2 скорости.

Фильтр для аудио - `atempo`. Есть одно маленькое предостережение: оно может принимать значения только от 0,5 (половина скорости) до 2 (удвоение скорости). Чтобы обойти это, вы можете использовать их один за другим:

```bash
ffmpeg -i input.wav -af "atempo=0.75" output.wav
ffmpeg -i input.mp3 -af "atempo=2.0,atempo=2.0" ouutput.mp3
```

Первая команда замедляет звук на 1/4 от первоначальной скорости. Вторая команда ускоряет звук в 4 раза (2\*2)

> Чтобы изменить скорость воспроизведения видео и аудио с помощью одной и той же команды, вам нужно использовать [filtergraphs](https://ffmpeg.org/ffmpeg-filters.html#Filtergraph-description)

#### 7. Добавить водяной знак

Для размещения водяного знака используем фильтр `overlay`, вместе с координатами его расположения на видео.

Например, вотермарк размером 100\*100 мы хотим расположить в центре видео с размерами 1280?720. Получим по горизонтали `x = (1280 - 100) / 2 = 590` и по вертикали `y = (720 - 100) / 2 = 310`. Поэтому значение будет `overlay=590:310`. Но удобнее использовать формулу `overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2`, где `main_w` и `main_h` - высота и ширина видео, а `overlay_w` и `overlay_h` - водяного знака. Получим команду:

```bash
ffmpeg -i source_video.mp4 -i watermark.png
-filter_complex "overlay=(main_w-overlay_w)/2:(main_h-overlay_h)/2"
-codec:a copy video_protected.mp4
```
