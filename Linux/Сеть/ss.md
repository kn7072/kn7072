https://blog.sedicomm.com/2018/03/28/komanda-ss-s-primerami-otobrazhenie-informatsii-o-seti-sokete-tcp-udp-v-linux/
https://losst.ru/monitoring-setevyh-podklyuchenij-v-linux

# ss
Команда ss — это инструмент, используемый для вывода сетевой статистики в виде, похожем на тот, который выдаёт команда netstat. Однако, ss делает это проще и быстрее, чем netstat. Кроме того, ss даёт более подробные сведения о TCP-подключениях и о состояниях соединений, чем большинство других инструментов. В частности, ss может выводить данные о таких сущностях, как PACKET, TCP, UDP, DCCP, RAW, и сокеты домена Unix. Команда ss проще, чем netstat. для того, чтобы в этом убедиться, достаточно сравнить страницы man этих двух инструментов. С помощью ss можно получить весьма подробные сведения о том, как машина, работающая под управлением Linux, обменивается данными с другими компьютерами. Всё это открывает возможности по диагностике и устранению различных сетевых ошибок.

## Общая информация

Как уже было сказано работает утилита ss в Linux на основе подсистемы ядра. Синтаксис очень простой - сама команда и ее опции:

__$ ss опции [фильтр_состояния] [фильтр_адреса]__

Для удобства вывод команды ss можно фильтровать с помощью grep:

__$ ss опции | grep шаблон__

Опции указывает различные параметры отображения и фильтрации информации. Фильтры по состоянию и адресу очень интересная вещь, они позволяют выполнять мониторинг сетевых подключений в Linux, только тех что нужно. Например, только открытых, закрытых или находящихся на этапе подключения. Подробнее мы рассмотрим это в конце статьи.

## Опции утилиты ss

Для сетевых подключений в Linux с помощью утилиты ss можно использовать такие опции:

    -V - Version показать версию утилиты.
    -n - Numeric не определять имена служб.
    -r - Resolve определять сетевые имена адресов с помощью DNS.
    -a - All отобразить все сокеты (открытые соединения).
    -l - Listening показать только прослушиваемые сокеты.
    -o - Options показать информацию таймера.
    -e - Extended выводить расширенную информацию о сокете.
    -m - показать использование памяти сокета
    -p - Processes, показать процессы, использующие сокет.
    -i - Internal, посмотреть внутреннюю информацию TCP.
    -s - Summary, статистика использования сокета.
    -D - экспортировать текущее состояние TCP сокетов в файл.
    -F - работать с информацией, взятой из файла.

Кроме того, можно вывести сокеты только нужного протокола:

    -4, --ipv4 - только сокеты протокола IP версии 4.
    -6 --ipv6 - только сокеты протокола IP версии 6.
    -0, --packet - только PACKET сокеты.
    -t, --tcp - TCP сокеты.
    -u, --udp - UDP сокеты.
    -d, --dhcp - DHCP сокеты.
    -r, --raw - RAW сокеты.
    -x, --unix - UNIX сокеты.

Для фильтрации протоколов можно использовать не только эти опции, но и универсальную опцию -f, передав ей в параметре название протокола. Здесь собраны самые основные опции, если вам нужно больше информации - смотрите справку команды.

## Интерпретация ответа
__sudo ss -tulpn__

Пример прослушиваемых портов на Linux: 

Netid State   Recv-Q   Send-Q         Local Address:Port     Peer Address:Port                                                                                  
udp   UNCONN  0        0           10.0.2.15%enp0s3:68            0.0.0.0:*      users:(("NetworkManager",pid=318,fd=17))                                       
udp   UNCONN  0        0                  127.0.0.1:5300          0.0.0.0:*      users:(("tor",pid=359,fd=7))                                                   
tcp   LISTEN  0        128                127.0.0.1:9040          0.0.0.0:*      users:(("tor",pid=359,fd=8))                                                   
tcp   LISTEN  0        128                127.0.0.1:8118          0.0.0.0:*      users:(("privoxy",pid=362,fd=3))                                               
tcp   LISTEN  0        128                127.0.0.1:9050          0.0.0.0:*      users:(("tor",pid=359,fd=6))                                                   
tcp   LISTEN  0        128                127.0.0.1:9475          0.0.0.0:*      users:(("httpd",pid=553,fd=5),("httpd",pid=552,fd=5),("httpd",pid=551,fd=5),("httpd",pid=550,fd=5),("httpd",pid=549,fd=5),("httpd",pid=360,fd=5))
tcp   LISTEN  0        128                        *:80                  *:*      users:(("httpd",pid=553,fd=4),("httpd",pid=552,fd=4),("httpd",pid=551,fd=4),("httpd",pid=550,fd=4),("httpd",pid=549,fd=4),("httpd",pid=360,fd=4))
tcp   LISTEN  0        128                        *:22                  *:*      users:(("systemd",pid=1,fd=55))                                                
tcp   LISTEN  0        128                        *:443                 *:*      users:(("httpd",pid=553,fd=7),("httpd",pid=552,fd=7),("httpd",pid=551,fd=7),("httpd",pid=550,fd=7),("httpd",pid=549,fd=7),("httpd",pid=360,fd=7))

### В выводимых данных имеются следующие поля:

- Netid — протокол udp или tcp
- State — состояние, для протоколов TCP здесь будет LISTEN (поскольку мы явно указали в опциях показать только прослушиваемые порты), а для протоколов UDP здесь будет UNCONN, то есть состояние неизвестно, но, на самом деле, это тоже прослушиваемые порты, которые позволяют подключаться из вне
- Recv-Q — получено
- Send-Q — отправлено
- Local Address:Port — локальный адрес и порт, к которому привязана служба, то есть IP адрес и порт, которые прослушиваются
- Peer Address:Port — удалённый адрес и порт, к которым выполнено соединение.

Рассмотрим, что означает запись 127.0.0.1:9050: она говорит о том, что прослушивается порт 9050. Причём он прослушивается только для IP адреса 127.0.0.1. Адрес 127.0.0.1 относится к так называемым Loopback, то есть это замыкающийся на себя, закольцованный адрес. Сетевой интерфейс с этим адресом называется петлевым. Пакеты, которые отправляются с компьютера на этот адрес, приходят на этот же самый компьютер (точнее говоря, они никуда даже не уходят). Доступ к этому адресу может иметь только служба, работающая на этом же самом компьютере. Отсюда важное следствие: хотя порт 9050 прослушивается, никто другой не может к нему подключиться из любой сети. Это же относится и к адресам из диапазона ::1/128 — это такие же адреса, но уже для IPv6, в IPv6 аналог для 127.0.0.1 это ::1 (тоже часто можно видеть в выводимой информации).

### Звёздочка (*) вместо адреса или порта:

 Мы можем увидеть записи вроде __*:80 или даже *:*__

Здесь звёздочка означает любой адрес или любой порт. 
Например, *:80 в колонке Local Address:Port (Локальный адрес:Порт) означает, что прослушивается 80 порт сразу на всех сетевых интерфейсах, доступных в данной системе. 
То есть служба ответит на запрос к 80 порту откуда бы он не пришёл: из локальной сети, из глобальной сети (если есть прямое соединение и интерфейс с белым IP) или с закольцованного адреса — это неважно, служба всё равно примет это соединение.

Кстати, служба может прослушивать порт в соответствии со следующими правилами:

    может прослушиваться конкретный порт для одного IP адреса
    может прослушиваться конкретный порт для любого IP адреса

То есть порт должен в любом случае быть указан, поэтому для Local Address:Port (Локальный адрес:Порт) допустима запись *:80, но запись вида *:* никогда не встретится в этом столбце.

Для Peer Address:Port (Удалённый адрес:Порт) запись *:* означает, что принимаются соединения от любого IP, отправленные с любого порта.

Кстати, просто для справки: если ваш компьютер подключается к веб сайту, то веб сайты обычно работают на 80 и 443 портах. Следовательно, веб браузер подключается именно к 80 порту (или 443, если это безопасное HTTPS соединение). Но на вашем компьютере открывается новое соединение на каком угодно, но только не на 80 и 443 портах — обычно используются порты с номерами >30000, например, на вашем компьютере может быть открыто исходящее соединение с портом 42063 и оно будет адресовано к 80 порту какого-либо веб сервера.

### Что означает 0.0.0.0 в netstat. Различные виды нотаций в netstat и ss

 0.0.0.0 — это самый первый IP адрес. Но он относится к IP специального назначения (как например 127.0.0.1) и выполняет разные функции.

Обозначение 0.0.0.0 может иметь разное значение в зависимости от того, где используется. Когда говорят о прослушиваемых портах, это обозначение в Linux символизирует заполнитель, то есть означает «любой IP адрес».

Чем это отличается от * (звёздочки) или от записи :::, которые также встречаются в выводе рассматриваемых программ? В программе ss IPv6 адрес 0:0:0:0:0:0:0:0 (который является аналогом IPv4 адреса 0.0.0.0) обозначается звёздочкой (*). Следовательно, в ss запись 0.0.0.0:* обозначает «любой IPv4 адрес с любого порта». А обозначение *:* символизирует «любой IPv6 адрес с любого порта».

В программе netstat также используется запись 0.0.0.0:* которая также обозначает «любой IPv4 адрес с любого порта».

Но в netstat для обозначения «любой IPv6 адрес с любого порта» используется :::*

Помните об этих различиях, чтобы не запутаться. А также помните о том, что если показано, что прослушивается протокол tcp6 (IPv6), то одновременно может прослушиваться порт и на tcp (IPv4) — при этом данные в выводимой информации отсутствуют!

В Windows в качестве Local Address (Локального адреса), когда прослушивается любой IP адрес на определённом порту, используется запись вида 0.0.0.0:80 (в этом примере прослушивается любой IP адрес, доступный в системе, на 80 порту). Для IPv6 адресов в этом случае используется запись вида [::]:80.

В качестве внешнего адреса, когда доступно подключения с любого IP и с любого порта, для TCP протокола пишется 0.0.0.0:0, а для UDP протокола в этих же условиях пишется *:*. Что тоже не особо логично и сбивает с толку. Точнее говоря такое различие в обозначениях вытекает из разницы протоколов TCP и UDP.

Если информация относится к IPv6, то для TCP когда имеется ввиду любой адрес на любом порту, используется запись вида [::]:0. А для UDP используются одинаковые нотации как для IP, так и для IPv6, то есть *:*

Нужно помнить, что некоторые из этих обозначений пересекаются с нотациями из Linux, где они имеют своё собственное значение.


## Примеры использования

-  Если запустить ss без аргументов командной строки или опций, она выведет полный список работающих соединений.

-  Посмотрим только TCP соединения:
    __sudo ss -t__ или __sudo ss -f tcp__

-  Теперь только Unix:
    __sudo ss -x__ или __sudo ss -xa__

-  Для отображения UDP сокетов используйте опцию u. По умолчанию будут показаны только подключенные соединения. Если хотите получить все, нужно использовать опцию __a__. Поскольку UDP, это протокол без постоянного соединения, то без опции __-a__ мы ничего не увидим:
    __sudo ss -ua__    

-  По умолчанию утилита не пытается определять имена хостов через dns, но можно ее попросить делать это опцией __-r__
    __sudo ss -tr__

-  Обратная опция __-n__, не будет выполняться не только dns резолвинг, но и определение протоколов портов, зато мониторинг сети в Linux работать будет быстрее:
    __sudo ss -tn__

-   Теперь просмотрим только прослушиваемые tcp сокеты.
    __sudo ss -tl__
    Здесь мы видим только имена служб, это не всегда удобно, указав опцию __n__, мы получим номера портов. Так же само можно посмотреть прослушиваемые udp сокеты:
    __sudo ss -tun__

-  Также мы можем попытаться узнать название и PID процесса, использующего сокет:
    __sudo ss -ltp__

-  Для просмотра статистики по использованию сетевых подключений наберите:
    __sudo ss -s__

-  С помощью опции __-о__ можно посмотреть информацию о таймере и состоянии подключения.
    __sudo ss -to__

-  Фильтрация по протоколу
    __sudo ss -tl -f inet4__ или __sudo ss -tl4__, или для ipv6 __sudo ss -tl6__

-  Фильтрация по состоянию соединения
    В синтаксисе команды мы описали два дополнительных параметра. Фильтрация состояния и фильтрация по адресу. Рассмотрим теперь как ими пользоваться. Сокет TCP может находиться в одном из нескольких состояний. Например, так утилита ss linux выведет только подключенные сокеты.
    __ss -t4 state established__
    или сокеты в состоянии ожидания __sudo ss -t4 state time-wait__

    Введите следующую команду, чтобы увидеть закрывающие сокеты:
    __sudo ss -4 state closing__

    В параметр state можно передать одно из следующих значений:
    - established
    - syn-sent
    - syn-recv
    - fin-wait-1
    - fin-wait-2
    - time-wait
    - closed
    - close-wait
    - last-ack
    - closing
    - all  - все состояния
    - connected - все кроме прослушиваемых и закрытых
    - synchronized - все кроме syn-sent
    - bucket -  time-wait и syn-recv
    - big - все кроме bucket
    Не все состояния подключений можно увидеть просто выполнив команду. Например, syn-sent и syn-recv вряд ли получиться словить, потому что соединения находятся в этом состоянии очень короткое время. Для их отображения удобно использовать команду watch:

    __watch -n 1 "ss -t4 state syn-sent"__

    После запуска команды откройте любой сайт в браузере. Вы увидите как появится одно или несколько соединений на несколько секунд.

-  Фильтрация по адресу и номеру порта
    Кроме фильтрации по состоянию, tcp сокеты можно фильтровать по адресам или портам соединений.

    Например, отберем все сетевые подключения linux с портом источником(удаленный порт dport) или приемником(локальный порт sport) ssh, то есть все входящие и исходящие соединения ssh:
    __ss -at '( dport = :ssh or sport = :ssh )'__
    Или сокеты с портом назначения 80 или 443:
    __ss -nt '( dst :443 or dst :80 )'__

    Такой синтаксис тоже будет работать:
    __ss -nt dst :443 or dst :80__

    Еще несколько примеров фильтрации:
    Фильтрация по адресу(Показать все порты, подключенные с удаленного 74.125.236.178):
    Одно из полезных применений ss заключается в том, чтобы получать с помощью этой команды сведения по соединениям, установленных с неких IP-адресов. Предположим, нужно выяснить, подключена ли машина, скажем, с IP-адресом 74.125.236.178 к нашему серверу, и если это так — узнать об этом подробности. Для решения этой задачи подойдёт такая команда:
    __ss -nt dst 74.125.236.178__

    Узнайте о подключении удаленного клиента с  123.1.2.100:http к нашим локальным виртуальным серверам:
    __ss dst 123.1.2.100:http__

    Фильтрация по адресу и подсети:
    __ss -nt dst 74.125.236.178/16__

    И по адресу и порту:
    __ss -nt dst 74.125.236.178:80__

    Если вы хотите фильтровать сетевые соединения по порту, перед портом ставьте двоеточие:
    __ss -nt dport = :80__

    Показать все установленные соединения SMTP
    __ss -o state established '( dport = :smtp or sport = :smtp )'__

    Показать все установленные HTTP-соединения
    __ss -o state established '( dport = :http or sport = :http )'__

    Найти все локальные процессы, подключенные к X-серверу
    __ss -x src /tmp/.X11-unix/*__

    Узнать все ips, связанные с ip-адресом nixcraft.com. 75.126.153.214 ###
    Показать все порты, подключенные к локальным 75.126.153.214 ##
    ss src 75.126.153.214

    http (80) port only
    __ss src 75.126.153.214:http__
    __ss src 75.126.153.214:80__

    smtp (25) port only
    __ss src 75.126.153.214:smtp__
    __ss src 75.126.153.214:25__

    Вывести список всех сокетов TCP в состоянии FIN-WAIT-1
    Выведите все сокеты TCP в состоянии -FIN-WAIT-1 для нашего httpd в сети 202.54.1/24 и посмотрите на их таймеры:
    __ss -o state fin-wait-1 '( sport = :http or sport = :https )' dst 202.54.1/24__

    Можно использовать такие операторы сравнения:

    <= или le - меньше или ровно порту.
    >= или ge - больше или ровно порту.
    == или eq - точное соответствие.
    != или ne - не равно.
    < или gt - меньше.
    > или lt - больше.
