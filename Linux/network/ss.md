https://blog.sedicomm.com/2018/03/28/komanda-ss-s-primerami-otobrazhenie-informatsii-o-seti-sokete-tcp-udp-v-linux/
https://losst.ru/monitoring-setevyh-podklyuchenij-v-linux

# ss

Команда ss — это инструмент, используемый для вывода сетевой статистики в виде, похожем на тот, который выдаёт команда netstat. Однако, ss делает это проще и быстрее, чем netstat. Кроме того, ss даёт более подробные сведения о TCP-подключениях и о состояниях соединений, чем большинство других инструментов. В частности, ss может выводить данные о таких сущностях, как PACKET, TCP, UDP, DCCP, RAW, и сокеты домена Unix. Команда ss проще, чем netstat. для того, чтобы в этом убедиться, достаточно сравнить страницы man этих двух инструментов. С помощью ss можно получить весьма подробные сведения о том, как машина, работающая под управлением Linux, обменивается данными с другими компьютерами. Всё это открывает возможности по диагностике и устранению различных сетевых ошибок.

## Общая информация

Как уже было сказано работает утилита ss в Linux на основе подсистемы ядра. Синтаксис очень простой - сама команда и ее опции:

**$ ss опции [фильтр_состояния] [фильтр_адреса]**

Для удобства вывод команды ss можно фильтровать с помощью grep:

**$ ss опции | grep шаблон**

Опции указывает различные параметры отображения и фильтрации информации. Фильтры по состоянию и адресу очень интересная вещь, они позволяют выполнять мониторинг сетевых подключений в Linux, только тех что нужно. Например, только открытых, закрытых или находящихся на этапе подключения. Подробнее мы рассмотрим это в конце статьи.

## Опции утилиты ss

Для сетевых подключений в Linux с помощью утилиты ss можно использовать такие опции:

    -V - Version показать версию утилиты.
    -n - Numeric не определять имена служб.
    -r - Resolve определять сетевые имена адресов с помощью DNS.
    -a - All отобразить все сокеты (открытые соединения).
    -l - Listening показать только прослушиваемые сокеты.
    -o - Options показать информацию таймера.
    -e - Extended выводить расширенную информацию о сокете.
    -m - показать использование памяти сокета
    -p - Processes, показать процессы, использующие сокет.
    -i - Internal, посмотреть внутреннюю информацию TCP.
    -s - Summary, статистика использования сокета.
    -D - экспортировать текущее состояние TCP сокетов в файл.
    -F - работать с информацией, взятой из файла.

Кроме того, можно вывести сокеты только нужного протокола:

    -4, --ipv4 - только сокеты протокола IP версии 4.
    -6 --ipv6 - только сокеты протокола IP версии 6.
    -0, --packet - только PACKET сокеты.
    -t, --tcp - TCP сокеты.
    -u, --udp - UDP сокеты.
    -d, --dhcp - DHCP сокеты.
    -r, --raw - RAW сокеты.
    -x, --unix - UNIX сокеты.

Для фильтрации протоколов можно использовать не только эти опции, но и универсальную опцию -f, передав ей в параметре название протокола. Здесь собраны самые основные опции, если вам нужно больше информации - смотрите справку команды.

## Интерпретация ответа

**sudo ss -tulpn**

Пример прослушиваемых портов на Linux:

```
Netid State Recv-Q Send-Q Local Address:Port Peer Address:Port
udp UNCONN 0 0 10.0.2.15%enp0s3:68 0.0.0.0:_ users:(("NetworkManager",pid=318,fd=17))
udp UNCONN 0 0 127.0.0.1:5300 0.0.0.0:_ users:(("tor",pid=359,fd=7))
tcp LISTEN 0 128 127.0.0.1:9040 0.0.0.0:_ users:(("tor",pid=359,fd=8))
tcp LISTEN 0 128 127.0.0.1:8118 0.0.0.0:_ users:(("privoxy",pid=362,fd=3))
tcp LISTEN 0 128 127.0.0.1:9050 0.0.0.0:_ users:(("tor",pid=359,fd=6))
tcp LISTEN 0 128 127.0.0.1:9475 0.0.0.0:_ users:(("httpd",pid=553,fd=5),("httpd",pid=552,fd=5),("httpd",pid=551,fd=5),("httpd",pid=550,fd=5),("httpd",pid=549,fd=5),("httpd",pid=360,fd=5))
tcp LISTEN 0 128 _:80 _:_ users:(("httpd",pid=553,fd=4),("httpd",pid=552,fd=4),("httpd",pid=551,fd=4),("httpd",pid=550,fd=4),("httpd",pid=549,fd=4),("httpd",pid=360,fd=4))
tcp LISTEN 0 128 _:22 _:_ users:(("systemd",pid=1,fd=55))
tcp LISTEN 0 128 _:443 _:\* users:(("httpd",pid=553,fd=7),("httpd",pid=552,fd=7),("httpd",pid=551,fd=7),("httpd",pid=550,fd=7),("httpd",pid=549,fd=7),("httpd",pid=360,fd=7))
```

### В выводимых данных имеются следующие поля:

- Netid — протокол udp или tcp
- State — состояние, для протоколов TCP здесь будет LISTEN (поскольку мы явно указали в опциях показать только прослушиваемые порты), а для протоколов UDP здесь будет UNCONN, то есть состояние неизвестно, но, на самом деле, это тоже прослушиваемые порты, которые позволяют подключаться из вне
- Recv-Q — получено
- Send-Q — отправлено
- Local Address:Port — локальный адрес и порт, к которому привязана служба, то есть IP адрес и порт, которые прослушиваются
- Peer Address:Port — удалённый адрес и порт, к которым выполнено соединение.

Рассмотрим, что означает запись 127.0.0.1:9050: она говорит о том, что прослушивается порт 9050. Причём он прослушивается только для IP адреса 127.0.0.1. Адрес 127.0.0.1 относится к так называемым Loopback, то есть это замыкающийся на себя, закольцованный адрес. Сетевой интерфейс с этим адресом называется петлевым. Пакеты, которые отправляются с компьютера на этот адрес, приходят на этот же самый компьютер (точнее говоря, они никуда даже не уходят). Доступ к этому адресу может иметь только служба, работающая на этом же самом компьютере. Отсюда важное следствие: хотя порт 9050 прослушивается, никто другой не может к нему подключиться из любой сети. Это же относится и к адресам из диапазона ::1/128 — это такие же адреса, но уже для IPv6, в IPv6 аналог для 127.0.0.1 это ::1 (тоже часто можно видеть в выводимой информации).

### Звёздочка (\*) вместо адреса или порта:

Мы можем увидеть записи вроде **_:80 или даже _:\***

Здесь звёздочка означает любой адрес или любой порт.
Например, \*:80 в колонке Local Address:Port (Локальный адрес:Порт) означает, что прослушивается 80 порт сразу на всех сетевых интерфейсах, доступных в данной системе.
То есть служба ответит на запрос к 80 порту откуда бы он не пришёл: из локальной сети, из глобальной сети (если есть прямое соединение и интерфейс с белым IP) или с закольцованного адреса — это неважно, служба всё равно примет это соединение.

Кстати, служба может прослушивать порт в соответствии со следующими правилами:

    может прослушиваться конкретный порт для одного IP адреса
    может прослушиваться конкретный порт для любого IP адреса

То есть порт должен в любом случае быть указан, поэтому для Local Address:Port (Локальный адрес:Порт) допустима запись _:80, но запись вида _:\* никогда не встретится в этом столбце.

Для Peer Address:Port (Удалённый адрес:Порт) запись _:_ означает, что принимаются соединения от любого IP, отправленные с любого порта.

Кстати, просто для справки: если ваш компьютер подключается к веб сайту, то веб сайты обычно работают на 80 и 443 портах. Следовательно, веб браузер подключается именно к 80 порту (или 443, если это безопасное HTTPS соединение). Но на вашем компьютере открывается новое соединение на каком угодно, но только не на 80 и 443 портах — обычно используются порты с номерами >30000, например, на вашем компьютере может быть открыто исходящее соединение с портом 42063 и оно будет адресовано к 80 порту какого-либо веб сервера.

### Что означает 0.0.0.0 в netstat. Различные виды нотаций в netstat и ss

0.0.0.0 — это самый первый IP адрес. Но он относится к IP специального назначения (как например 127.0.0.1) и выполняет разные функции.

Обозначение 0.0.0.0 может иметь разное значение в зависимости от того, где используется. Когда говорят о прослушиваемых портах, это обозначение в Linux символизирует заполнитель, то есть означает «любой IP адрес».

Чем это отличается от _ (звёздочки) или от записи :::, которые также встречаются в выводе рассматриваемых программ? В программе ss IPv6 адрес 0:0:0:0:0:0:0:0 (который является аналогом IPv4 адреса 0.0.0.0) обозначается звёздочкой (_). Следовательно, в ss запись 0.0.0.0:_ обозначает «любой IPv4 адрес с любого порта». А обозначение _:\* символизирует «любой IPv6 адрес с любого порта».

В программе netstat также используется запись 0.0.0.0:\* которая также обозначает «любой IPv4 адрес с любого порта».

Но в netstat для обозначения «любой IPv6 адрес с любого порта» используется :::\*

Помните об этих различиях, чтобы не запутаться. А также помните о том, что если показано, что прослушивается протокол tcp6 (IPv6), то одновременно может прослушиваться порт и на tcp (IPv4) — при этом данные в выводимой информации отсутствуют!

В Windows в качестве Local Address (Локального адреса), когда прослушивается любой IP адрес на определённом порту, используется запись вида 0.0.0.0:80 (в этом примере прослушивается любой IP адрес, доступный в системе, на 80 порту). Для IPv6 адресов в этом случае используется запись вида [::]:80.

В качестве внешнего адреса, когда доступно подключения с любого IP и с любого порта, для TCP протокола пишется 0.0.0.0:0, а для UDP протокола в этих же условиях пишется _:_. Что тоже не особо логично и сбивает с толку. Точнее говоря такое различие в обозначениях вытекает из разницы протоколов TCP и UDP.

Если информация относится к IPv6, то для TCP когда имеется ввиду любой адрес на любом порту, используется запись вида [::]:0. А для UDP используются одинаковые нотации как для IP, так и для IPv6, то есть _:_

Нужно помнить, что некоторые из этих обозначений пересекаются с нотациями из Linux, где они имеют своё собственное значение.

## Примеры использования

- Если запустить ss без аргументов командной строки или опций, она выведет полный список работающих соединений.

- Посмотрим только TCP соединения:
  **sudo ss -t** или **sudo ss -f tcp**

- Теперь только Unix:
  **sudo ss -x** или **sudo ss -xa**

- Для отображения UDP сокетов используйте опцию u. По умолчанию будут показаны только подключенные соединения. Если хотите получить все, нужно использовать опцию **a**. Поскольку UDP, это протокол без постоянного соединения, то без опции **-a** мы ничего не увидим:
  **sudo ss -ua**

- По умолчанию утилита не пытается определять имена хостов через dns, но можно ее попросить делать это опцией **-r**
  **sudo ss -tr**

- Обратная опция **-n**, не будет выполняться не только dns резолвинг, но и определение протоколов портов, зато мониторинг сети в Linux работать будет быстрее:
  **sudo ss -tn**

- Теперь просмотрим только прослушиваемые tcp сокеты.
  **sudo ss -tl**
  Здесь мы видим только имена служб, это не всегда удобно, указав опцию **n**, мы получим номера портов. Так же само можно посмотреть прослушиваемые udp сокеты:
  **sudo ss -tun**

- Также мы можем попытаться узнать название и PID процесса, использующего сокет:
  **sudo ss -ltp**

- Для просмотра статистики по использованию сетевых подключений наберите:
  **sudo ss -s**

- С помощью опции **-о** можно посмотреть информацию о таймере и состоянии подключения.
  **sudo ss -to**

- Фильтрация по протоколу
  **sudo ss -tl -f inet4** или **sudo ss -tl4**, или для ipv6 **sudo ss -tl6**

- Фильтрация по состоянию соединения
  В синтаксисе команды мы описали два дополнительных параметра. Фильтрация состояния и фильтрация по адресу. Рассмотрим теперь как ими пользоваться. Сокет TCP может находиться в одном из нескольких состояний. Например, так утилита ss linux выведет только подключенные сокеты.
  **ss -t4 state established**
  или сокеты в состоянии ожидания **sudo ss -t4 state time-wait**

  Введите следующую команду, чтобы увидеть закрывающие сокеты:
  **sudo ss -4 state closing**

  В параметр state можно передать одно из следующих значений:

  - established
  - syn-sent
  - syn-recv
  - fin-wait-1
  - fin-wait-2
  - time-wait
  - closed
  - close-wait
  - last-ack
  - closing
  - all - все состояния
  - connected - все кроме прослушиваемых и закрытых
  - synchronized - все кроме syn-sent
  - bucket - time-wait и syn-recv
  - big - все кроме bucket
    Не все состояния подключений можно увидеть просто выполнив команду. Например, syn-sent и syn-recv вряд ли получиться словить, потому что соединения находятся в этом состоянии очень короткое время. Для их отображения удобно использовать команду watch:

  **watch -n 1 "ss -t4 state syn-sent"**

  После запуска команды откройте любой сайт в браузере. Вы увидите как появится одно или несколько соединений на несколько секунд.

- Фильтрация по адресу и номеру порта
  Кроме фильтрации по состоянию, tcp сокеты можно фильтровать по адресам или портам соединений.

  Например, отберем все сетевые подключения linux с портом источником(удаленный порт dport) или приемником(локальный порт sport) ssh, то есть все входящие и исходящие соединения ssh:
  **чтобы команда выполнилась необходимо оставлять пробелы между всеми элементами внутри кавычек**
  **ss -at '( dport = :ssh or sport = :ssh )'**
  Или сокеты с портом назначения 80 или 443:
  **ss -nt '( dst :443 or dst :80 )'**

  Такой синтаксис тоже будет работать:
  **ss -nt dst :443 or dst :80**

  Еще несколько примеров фильтрации:
  Фильтрация по адресу(Показать все порты, подключенные с удаленного 74.125.236.178):
  Одно из полезных применений ss заключается в том, чтобы получать с помощью этой команды сведения по соединениям, установленных с неких IP-адресов. Предположим, нужно выяснить, подключена ли машина, скажем, с IP-адресом 74.125.236.178 к нашему серверу, и если это так — узнать об этом подробности. Для решения этой задачи подойдёт такая команда:
  **ss -nt dst 74.125.236.178**

  Узнайте о подключении удаленного клиента с 123.1.2.100:http к нашим локальным виртуальным серверам:
  **ss dst 123.1.2.100:http**

  Фильтрация по адресу и подсети:
  **ss -nt dst 74.125.236.178/16**

  И по адресу и порту:
  **ss -nt dst 74.125.236.178:80**

  Если вы хотите фильтровать сетевые соединения по порту, перед портом ставьте двоеточие:
  **ss -nt dport = :80**

  Показать все установленные соединения SMTP
  **ss -o state established '( dport = :smtp or sport = :smtp )'**

  Показать все установленные HTTP-соединения
  **ss -o state established '( dport = :http or sport = :http )'**

  Найти все локальные процессы, подключенные к X-серверу
  **ss -x src /tmp/.X11-unix/\***

  Узнать все ips, связанные с ip-адресом nixcraft.com. 75.126.153.214 ###
  Показать все порты, подключенные к локальным 75.126.153.214 ##
  ss src 75.126.153.214

  http (80) port only
  **ss src 75.126.153.214:http**
  **ss src 75.126.153.214:80**

  smtp (25) port only
  **ss src 75.126.153.214:smtp**
  **ss src 75.126.153.214:25**

  Вывести список всех сокетов TCP в состоянии FIN-WAIT-1
  Выведите все сокеты TCP в состоянии -FIN-WAIT-1 для нашего httpd в сети 202.54.1/24 и посмотрите на их таймеры:
  **ss -o state fin-wait-1 '( sport = :http or sport = :https )' dst 202.54.1/24**

  Можно использовать такие операторы сравнения:

  <= или le - меньше или ровно порту.

  > = или ge - больше или ровно порту.
  > == или eq - точное соответствие.
  > != или ne - не равно.
  > < или gt - меньше.
  > или lt - больше.
