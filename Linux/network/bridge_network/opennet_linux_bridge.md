[источник](https://www.opennet.ru/base/net/linux_bridge.txt.html)
From: Игорь Чубин <[http://xgu.ru>](http://xgu.ru>);
Date: Sun, 10 Mar 2008 17:02:14 +0000 (UTC)
**Subject: Сетевые мосты в Linux**

Оригинал: [http://xgu.ru/wiki/Linux_Bridge](http://xgu.ru/wiki/Linux_Bridge)

Linux Bridge

Материал из Xgu.ru.
Оригинал: [http://linux-net.osdl.org/index.php/Bridge](http://linux-net.osdl.org/index.php/Bridge)
Перевод: Игорь Чубин <[http://xgu.ru>](http://xgu.ru>);

Бридж (англ. bridge, мост) - это способ соединения двух сегментов
Ethernet на канальном уровне, т.е. без использования протоколов более
высокого уровня, таких как IP. Пакеты передаются на основе
Ethernet-адресов, а не IP-адресов (как в маршрутизаторе). Поскольку
передача выполняется на канальном уровне (уровень 2 модели OSI), все
протоколы более высокого уровня прозрачно проходят через мост.

Термины коммутатор, мост и бридж могут использоваться на данной
странице как взаимознаменяемые.

Код bridge в Linux является частичной реализацией стандарта ANSI/IEEE
802.1d [[[http://standards.ieee.org/getieee802/](http://standards.ieee.org/getieee802/) [2].]] Впервые бриджинг в Linux появился в 2.2, затем код был
переписан Леннертом Буйтенхеком (Lennert Buytenhek). Код bridge
интегрирован в ядра серий 2.4 и 2.6.

Содержание

        * 1 Коммутация и фильтрация
        * 2 Состояние
        * 3 Скачивание
        * 4 Ручная конфигурация
             + 4.1 Сетевые карты
             + 4.2 Загрузка модуля
             + 4.3 Создание и удаление коммутатора
             + 4.4 Включение устройства в коммутатор
             + 4.5 Просмотр устройств
             + 4.6 Spanning Tree Protocol
                  - 4.6.1 Настройка STP
                       - 4.6.1.1 Приоритет коммутатора
                       - 4.6.1.2 Приоритет и стоимость
                       - 4.6.1.3 Задержка передачи (Forwarding delay)
                       - 4.6.1.4 Время Hello
                       - 4.6.1.5 max age - таймаут hello
             + 4.7 Пример настройки
        * 5 Конфигурирование через /etc/net
        * 6 FAQ
             + 6.1 Что делает мост/коммутатор?
             + 6.2 Это как-то зависит от используемых протоколов?
             + 6.3 Чем этот код лучше чем аппаратный коммутатор?
             + 6.4 Чем этот код хуже чем аппаратный коммутатор?
             + 6.5 Какова производительность моста?
             + 6.6 Моего моста не видно в трассе traceroute'а!
             + 6.7 Ничего не работает!
             + 6.8 Работает ли бриджинг на ядре 2.2?
             + 6.9 Есть ли в планах поддержка RSTP (802.1w)?
             + 6.10 Что можно соединять с помощью моста?
             + 6.11 Можно ли выполнять коммутацию в сочетании с
               netfilter/iptables?
             + 6.12 Работает ли он с Token Ring, FDDI и Firewire?
             + 6.13 Я продолжаю получать сообщение retransmitting tcn bpdu!
             + 6.14 Оно не работает с моей обычной ethernet-карточкой!
             + 6.15 Оно не работает с моей wireless-карточкой!
             + 6.16 И всё же я не понимаю!!
             + 6.17 Я получаю ошибку 'too much work in interrupt'
             + 6.18 Работает ли DHCP через/поверх моста?
        * 7 Контактная информация
        * 8 Дополнительная информация

**Коммутация и фильтрация**
Linux-мосты более мощные чем простые аппаратные мосты и коммутаторы,
поскольку они могут ещё фильтровать и регулировать трафик. Комбинация
коммутатора и брандмауэра выполняется с помощью родственного проекта
[ebtables.](http://ebtables.sourceforge.net/)

**Состояние**
Код обновляется как часть ядра Linux 2.4 и 2.6, доступного на
kernel.org.

Возможные будущие усовершенствования:
_ Описать фильтрацию STP
_ Использовать Netlink interface для управление бриджами (прототип в 2.6.18)
_ Добавить поддержку в user space
_ Сделать поддержку RSTP и других расширений 802.1d STP

**Скачивание**
Поддержка бриджинга есть в текущих ядрах 2.4 и 2.6 всех основных
дистрибутивов Linux. Требуемый комплект утилит для администрирования
bridge-utils есть практически во всех дистрибутивах.

Инсталляция утилит выполняется стандартным для дистрибутива способом.
Например, в Debian GNU/Linux:

```bash
         sudo apt-get install bridge-utils
```

Исходный код последнего релиза утилит можно получить со страницы
[Download.](http://sourceforge.net/project/showfiles.php?group_id=26089)

Как вариант можно сделать свою самую последнюю сборку кода с
[kernel.org](http://kernel.org/) и собрать утилиты bridge-utils из GIT-репозитория.

```bash
         $ git clone git://git.kernel.org/pub/scm/linux/kernel/git/shemminger/bridge-utils.git
         $ cd bridge-utils
         $ autoconf
         $ ./configure
```

**Ручная конфигурация**
Сетевые карты

Перед тем как вы приступите к настройке коммутатора, убедитесь, что
сетевые карты работают нормально. Не устанавливайте на них IP-адресов,
и не позволяйте начальным скриптам выполнять DHCP-запрос с них.
IP-адреса должны устанавливаться уже после того как бридж
сконфигурирован.

Команда [ifconfig](http://xgu.ru/w/index.php?title=Ifconfig&action=edit) должна показывать обе (или больше, если их
бюольше) сетевые карты, и они должны быть выключены, т.е. находиться в
состоянии DOWN.

**Загрузка модуля**

В большинстве случаев код коммутатора оформляется в виде модуля. Если
модуль сконфигурирован и установлен корректно, он автоматически
загружается при первом вызове команды brctl.

Если ваши утилиты bridge-utilities корректно установлены, и ядро и его
модуль bridge в порядке, вызовом команды brctl можно будет просмотреть
маленькую сводку о синтаксисе команды:

```bash
        # brctl
```

```
        # commands:
                addbr           <bridge>                add bridge
                delbr           <bridge>                delete bridge
                addif           <bridge> <device>       add interface to bridge
                delif           <bridge> <device>       delete interface from bridge
                setageing       <bridge> <time>         set ageing time
                setbridgeprio   <bridge> <prio>         set bridge priority
                setfd           <bridge> <time>         set bridge forward delay
                sethello        <bridge> <time>         set hello time
                setmaxage       <bridge> <time>         set max message age
                setpathcost     <bridge> <port> <cost>  set path cost
                setportprio     <bridge> <port> <prio>  set port priority
                show                                    show a list of bridges
                showmacs        <bridge>                show a list of mac addrs
                showstp         <bridge>                show bridge stp info
                stp             <bridge> <state>        turn stp on/off
```

**Создание и удаление коммутатора**
Команда

```bash
         brctl addbr "bridgename"
```

создаёт экземпляр логического коммутатора с именем bridgename. Для
того чтобы выполнять коммутацию пакетов, нужно создать хотя бы один
коммутатор . Можно воспринимать логический бридж как контейнер
интерфейсов, принимающих участие в коммутации. Каждый экземпляр
коммутатора представлен новым сетевым интерфейсом.

Соответствующая команда для выключения коммутатора:

```bash
         brctl delbr bridgename
```

**Включение устройства в коммутатор**

Команда

```bash
         brctl addif bridgename device
```

включает сетевое устройство device в коммутатор с именем "bridgename."
Все устройства, включенные в один бридж работают как одна большая
сеть. Нельзя добавить устройство в несколько бриджей одновременно,
поскольку это не имеет никакого смысла. Коммутатору потребуется
небольшое время после того как устройство подключено, для того чтобы
узнать его Ethernet-адрес, а затем он начинает делать перенаправление
(forward).

Соответствующая команда для выключения устройства из коммутатора:

```bash
         brctl delif  bridgename device
```

**Просмотр устройств**

Команда `bashbrctl show `показывает состояние всех работающих коммутаторов:

```
         # brctl addbr br549
         # brctl addif br549 eth0
         # brctl addif br549 eth1
         # brctl show
         bridge name     bridge id               STP enabled     interfaces
         br549           8000.00004c9f0bd2       no              eth0
                                                                 eth1
```

Если выполнить команду brctl showmacs, будет показана информация о
сетевых адресах источников трафика, прошедшего через коммутатор (и
самого коммутатора тоже):

```bash
         # brctl showmacs br549
```

```
         port no mac addr                is local?       ageing timer
           1     00:00:4c:9f:0b:ae       no                17.84
           1     00:00:4c:9f:0b:d2       yes                0.00
           2     00:00:4c:9f:0b:d3       yes                0.00
           1     00:02:55:1a:35:09       no                53.84
           1     00:02:55:1a:82:87       no                11.53
          ...
```

Время жизни (aging time) - это количество секунд, которое MAC-адрес
будет находится в таблице orwarding database после получения пакета с
этим адресом. Записи в таблице периодически удаляются по тайм-ауту,
для того чтобы не получилось, что они будут находиться там вечно. В
нормальной ситуации, не понадобится менять данные параметры, но это
сделать можно (время указывается в секундах)

```bash
          # brctl setageing bridgename time
```

Если установить время в ноль, запись становится постоянной.

**Spanning Tree Protocol**

Если используется несколько коммутаторов, для того чтобы избежать
петель коммутации, нужно включить поддержку протокола Spanning Tree
Protocol (Протокол остовного дерева).

```bash
         # brctl stp br549 on
```

Посмотреть параметры STP можно так:

```bash
         # brctl showstp br549
```

```
         br549
          bridge id              8000.00004c9f0bd2
          designated root        0000.000480295a00
          root port                 1                    path cost                104
          max age                  20.00                 bridge max age           200.00
          hello time                2.00                 bridge hello time         20.00
          forward delay           150.00                 bridge forward delay      15.00
          ageing time             300.00                 gc interval                0.00
          hello timer               0.00                 tcn timer                  0.00
          topology change timer     0.00                 gc timer                   0.33
          flags

         eth0 (1)
          port id                8001                    state                   forwarding
          designated root        0000.000480295a00       path cost                100
          designated bridge      001e.00048026b901       message age timer         17.84
          designated port        80c1                    forward delay timer        0.00
          designated cost           4                    hold timer                 0.00
          flags

         eth1 (2)
          port id                8002                    state                   disabled
          designated root        8000.00004c9f0bd2       path cost                100
          designated bridge      8000.00004c9f0bd2       message age timer          0.00
          designated port        8002                    forward delay timer        0.00
          designated cost           0                    hold timer                 0.00
          flags
```

**Настройка STP**

Конфигурироваться может несколько параметров, имеющих отношение к
Spanning Tree Protocol. Код автоматически определяет скорость
соединения и другие параметры, поэтому, как правило, вручную их менять
не нужно.

**Приоритет коммутатора**
У каждого коммутатора есть относительный приоритет (priority) и
стоимость (cost). Каждый интерфейс коммутатора ассоциируется с номером
порта в коде STP. У каждого есть приоритет и стоимость, на основе
которых принимается решение о том, какой путь для передчи пакета
является кратчайшим. Всегда используется путь с наимеьшей стоимостью
(за исключением случая, когда этот путь разорван). Если у вас
несколько коммутаторов и интерфейсов, может понадобиться
отрегулировать приоритеты, чтобы достичь максимальной
производительности.

```bash
          # brctl setbridgeprio bridgename priority
```

Бридж с наименьшим приоритетом избирается как корневой. Корневой бридж
является центром остовного дерева (spanning tree) коммутационных
связей.

**Приоритет и стоимость**

У каждого интерфейса моста может быть своя собственная скорость, и её
значение используется при выборе какое соединение должно
использоваться. У более быстрых интерфейсов должна быть более низкая
стоимость.

```bash
         # brctl setpathcost bridge port cost
```

Для разных портов, имеющих одинаковую стоимость существует ещё
приоритет.

**Задержка передачи (Forwarding delay)**

Задержка передачи (forwarding delay) это время в течение которого порт
находится в состояниях Listening и Learning, прежде чем перейти в
состояние Forwarding. Это время нужно для того чтобы мост, когда он
включается в сеть, сначала должен ознакомиться с трафиком, прежде чем
включаться в работу.

```bash
         #  brctl setfd bridgename time
```

**Время Hello**

Время от времени корневой мост (Root Bridge) и выделенные мосты
(Designated Bridges) отправляют пакет hello. Пакеты hello нужны для
обмена информацией о топологии все коммутироемой локальной сети.

```bash
         # brctl sethello bridgename time
```

        max age - таймаут hello

Если другой коммутатор в дереве spanning tree не отправляет пакет
hello в течение долгого времени, считается, что он не в порядке
(dead). Таймаут устанавливается командой:

```bash
         # brctl maxage  bridgename time
```

**Пример настройки**
Базовая настройка моста выполняется так:

```
         # ifconfig eth0 0.0.0.0
         # ifconfig eth1 0.0.0.0
         # brctl addbr mybridge
         # brctl addif mybridge eth0
         # brctl addif mybridge eth1
         # ifconfig mybridge up
```

Хост настраивается как обычный мост. У него самого нет IP-адреса,
поэтому к нему нельзя получить доступ (или взломать) удалённо по
TCP/IP.

Опционально можно настроить виртуальный интерфейс mybridge на доступ
по локальной сети. Он будет работать как обычный интерфейс - как
сетевая карта. Процесс настройки полностью совпадает с вышеописанным,
за тем исключением, что нужно заменить последнюю команду на такую:

```bash
         # ifconfig mybridge 192.168.100.5 netmask 255.255.255.0
```

Если вы хотите чтобы мост автоматически получал IP-адрес у ADSL-модема
по DHCP (или в другой похожей ситуации), сделайте так:

```
         # ifconfig eth0 0.0.0.0
         # ifconfig eth1 0.0.0.0
         # brctl addbr mybridge
         # brctl addif mybridge eth0
         # brctl addif mybridge eth1
         # dhclient mybridge
```

Если делать это много раз, процессов dhclient может расплодиться
великое множество. Или безжалостно убейте их, или почитайте о omshell.

**Конфигурирование через /etc/net**

Сначала в /etc/net настраиваются два ethernet-устройства port0 и
port1:

```
         # cat >> /etc/net/iftab
         port0 mac 00:13:46:66:01:5e
         port1 mac 00:13:46:66:01:5f
         ^D
         # mkdir /etc/net/ifaces/port0
         # cat > /etc/net/ifaces/port0/options
         TYPE=eth
         MODULE=via-rhine
         # mkdir /etc/net/ifaces/port1
         # cat > /etc/net/ifaces/port1/options
         TYPE=eth
         MODULE=via-rhine
         ^D
```

После этого описывается мост:

```
         # mkdir /etc/net/ifaces/mybridge
         # cat > /etc/net/ifaces/mybridge/options
         TYPE=bri
         HOST='port0 port1'
         ^D
         # cat > /etc/net/ifaces/mybridge/brctl
         stp AUTO on
         ^D
```

После этого можно поднять бридж командой ifup mybridge. Устройства
port0 и port1 поднимутся автоматически.

**FAQ**

> Что делает мост/коммутатор?

Мост прозрачно пересылает трафик между несколькими сетевыми
интерфейсами. На простом языке это означает, что коммутатор соединяет
два или более интерфейсов Ethernet между собой, для того чтобы
получилась большая Ethernet-сеть.

> Это как-то зависит от используемых протоколов?

Нет. Коммутатор ничего не знает о протоколах высокого уровня, он
только видит кадры Ethernet. Поэтому функциональность моста является
протоколонезависимой и проблем с передачей протоколов таких как IPX,
NetBEUI, IP, IPv6 и других быть не должно.

> Чем этот код лучше чем аппаратный коммутатор?

Пожалуйста, имейте в виду, что этот код не писался с целью заменить
Linux-боксами выделенное сетевое оборудование. Не надо воспринимать
Linux с этим кодом как замену аппаратным коммутаторам. Это скорее
расширение сетевых возможностей Linux. Как бывает, что
Linux-маршрутизатор лучше чем аппаратный маршрутизатор (и наоборот),
есть ситуации, когда Linux-мост лучше чем выделенный мост (и
наоборот).

Основная сила кода моста Linux это его гибкость. И так есть уже
огромнейшее количество всяких интересных вещей, которые можно делать с
Linux (см. например, [Linux](http://lartc.org/) Advanced Routing and Traffic Control),
и мосты - ещё одно добавление к этой гремучей смеси.

Одним из главных преимуществ решения, базирующегося на Linux, в
сравнении с выделенным коммутатором являются разнообразные возможности
по фильтрации трафика. Можно использовать всю функциональность
netfilter (iptables) в комбинации с мостами, что даёт больший
функционал, чем проприетарные решения.

> Чем этот код хуже чем аппаратный коммутатор?

Для того чтобы работать в качестве моста, устройство должно быть
переведено в неразборчивый (promiscuous) режим, в котором оно получает
весь трафик, приходящий на интерфейс. В действительно загруженных
сетях, это может занять значительную часть процессора, замедляя работу
системы. Выход - или использовать выделенную Linux-систему в качестве
моста или использовать аппаратный коммутатор.

> Какова производительность моста?

Производительность ограничивается используеммыми сетевыми картами и
процессором. Джеймс Ю (James Yu) из университета DePaul провёл
исследование, в котором выполнил сравнение Linux моста и коммутатора
Catalyst [Yu-Linux-TSM2004.pdf](http://facweb.cti.depaul.edu/jyu/Publications/Yu-Linux-TSM2004.pdf)

> Моего моста не видно в трассе traceroute'а!

И не должно быть видно. Работа моста является полностью прозрачной для
сети (по крайней мере должна); сети, которые мост соединяет между
собой должны видеться как одна большая сеть. Именно поэтому мост и не
виден в traceroute; пакеты и не думают о том, что они пересекают
границы подсети.

Дополнительная информация об этом в книгах по сетям TCP/IP.

> Ничего не работает!

Когда я пытаюсь добавить мост, система говорит: "br_add_bridge: bad
address"!

Или ваше ядро слишком старое (2.2 или более ранее), или вы забыли
включить поддержку бриджей в ядро.

> Работает ли бриджинг на ядре 2.2?

Изначально разработка велась на 2.2, есть патчи для этого ядра. Но
сейчас эти патчи уже не поддерживаются и не развиваются.

> Есть ли в планах поддержка RSTP (802.1w)?

Да. Ведётся работа по включению поддержки RSTP в будущий релиз для
ядра 2.6. Код делался для ядра 2.4 и нуждается в доработке,
тестировании и обновлении.

> Что можно соединять с помощью моста?

Мосты Linux очень гибкие; можно соединять как традиционные
ethernet-устройства, так и псевдоустройства такие как PPP, VPN или
VLAN'ы.

Ограничения, которые накладываются на соединяемые устройства: \* У всех должен быть одинаковый максимальный размер пакета (MTU).
Мост не выполняет фрагментирование пакетов.

     * Устройства  должны  выглядеть как Ethernet, т.е. у них должны быть
       6-байтные адреса отправителя и получателя.

     * Должен  поддерживаться  неразборчивый  (promiscuous)  режим.  Мост
       должен  получать  не  только  трафик,  адресованный ему, но и весь
       сетевой трафик.

     * Должен   быть  разрешён  спуфинг  адресов.  У  моста  должна  быть
       возможность  отправлять  данные по сети, как если бы они пришли от
       другого хоста.

> Можно ли выполнять коммутацию в сочетании с netfilter/iptables?

Да. Соответствующий код включен в большинство ядер. Смотрите проект
[ebtables.](http://xgu.ru/w/index.php?title=Ebtables&action=edit)

> Работает ли он с Token Ring, FDDI и Firewire?

Нет. У этих протоколов отличается адресация и размер кадра.

> Я продолжаю получать сообщение retransmitting tcn bpdu!

Это означает, что ваш Linux-мост ретранслирует сообщение Topology
Change Notification Bridge Protocol Data Unit (теперь хотя бы
известно, что означают эти хитрые буквы :). Если серьёзно, это
означает что где-то есть коммутатор (или другой Linux-мост), который
не согласен с правилами STP.

В каждой коммутируемой сети есть один "главный коммутатор", который
также называется корневым (root). Какой именно мост является корневым
можно узнать с помощью brctl.

Когда топология коммутируемой сети меняется (например, кто-то выдернул
кабель между коммутаторами), коммутатор, который это обнаружил,
отправляет сообщение корневому коммутатору. Корневой коммутатор
устанавливает бит 'topology changed' в пакеты hello, которые будут
отправляеться в течение следующих X секунд (обычно X равно 30). В
результате все мосты узнают об изменении топологии, и они могут
работать с учётом этого - например удалить устаревшие MAC-записи.

После того как коммутатор отправляет сообщение об изменении топологии,
он ждёт что в hello-сообщении будет установлени бит '"topology
changed". Если его нет (бит в данном случае играет роль подтверждения
получения информации о смене топологии), коммутатор решает, что
сообщение было потеряно. Поэтому пересылает сообщение повторно.
Однако, в некоторых коммутаторах реализациия STP немного недоделанная,
и они не отправляют подтверждение получения сообщения об изменении
топологии. Если один из таких коммутаторов у вас корневой, все
остальные коммутаторы будут постоянно повторно пересылать информацию
об изменении топологии. В результате чего и будут появляеться такие
сообщения.

Список вещей, которые можно сделать: \* Найти какой коммутатор является корневым, где он находится и под
управлением какого программного обеспечения работает. Пожалуйста,
сообщите о таком коммутаторе в список рассылки, чтобы можно было
его добавить в blacklist.

     * Заставить  Linux-мост  быть  корневым.  Найдите  какой приоритет у
       коммутатора, который сейчас является корневым, и с помощью команды
       brctl  'setbridgeprio' установите приоритет линуксового моста на 1
       меньше (Мост с наименьшим приоритеом всегда становится корневым).

     * Вообще  отключите  STP  на  Linux-мосте.  Только смотрите чтобы не
       появилось  петель коммутации! Если у вас есть петли, и не работает
       STP,  пакеты  зациклятся и будут гулять по сети вечно, что сделает
       её нерабочей.

> Оно не работает с моей обычной ethernet-карточкой!

К сожалению, у некоторых сетевых карт глючные драйверы, которые сбоят
во время загрузки. Ситуация улучшается, поэтому может помочь установка
текущего ядра и сетевых драйверов. Ещё можно попробовать устройства
другого производителя.

Пожалуйста, сообщайте обо всех проблемах в список рассылки "Bridge
mailing list": bridge@osdl.org. Если ваша сетевая карта не работает
даже без бриджинга, попробуйте обратиться в список рассылки "Linux
networking mailing list" linux-net@vger.kernel.org.

> Оно не работает с моей wireless-карточкой!

Это известная проблема, и она не связана с кодом моста. Большое
количество wireless-карт не позволяет делать подмену (spoofing) адреса
источника. В некоторых чипсетах это ограничение на уровне прошивки
(firmware). Дополнительная информация может быть найдена в архивах
списков рассылки.

Удалось ли кому-нибудь обойти проблему связанную с тем, что Wavelan не
позволяет использовать никакие MAC-адреса за исключением своего
собственного?

(Отвечает Michael Renzmann, mrenzmann at compulan.de)

99% пользователей никогда не смогут избавиться от этой проблемы. Для
такой функции нужна специальная прошивка. Её нужно загрузить в память
WaveLAN-карточки и тогда карточка сможет выполнять бриджинг. Но нет
общедоступной документации интерфейса. Единственный выход - иметь
полную версию библиотеки hcf, которая контролирует все действия карты,
и в частности, доступ к памяти карты. Для получения этой библиотеки
нужно убедить компанию Lucent, что это ей будет выгодно и помимо этого
подписать NDA. Поэтому, скорее всего, пока Lucent не передумает, вам
не удастся получить доступ к коду (а в том, что Lucent передумает есть
большие сомнения).

Если вам срочно нужна wireless-карта которая может работать в мосте,
нужно использовать те, что построены на базе чипсета prism
(изготавливает Harris Intersil). Драйверы для этой карты есть на
[http://www.linux-wlan.com](http://www.linux-wlan.com) (веб-сайт от Absoval), и в одном из сообщений
говорится, что общедоступна необходимая прошивка и программа для
загрузки для Linux. Если вам нужны какие-то дополнительные
возможности, нужно разговаривать с Absoval.

> И всё же я не понимаю!!

Полноценный мост для беспроводных сетей (802.11) требует поддержки
[WDS.](http://en.wikipedia.org/wiki/WDS) В текущей реализации её нет.

Можно сделать ограниченную функциональность с некоторыми драйверами.
Для этого обязательно чтобы устройство поддерживало разные адреса
отправителя и получателя. Что и обеспечивает WDS.

Есть способы добиться чтобы оно заработало, но они достаточно
запутанные, и их сложно понять без досконального знания 802.11,
режимов его работы и формата загловка кадра.

> Я получаю ошибку 'too much work in interrupt'

Это связано с тем, что сетевая карта теряет пакеты. Можно попробовать
несколько вещей. Во-первых, собрать драйвер с поддержкой NAPI (если он
по умолчанию, не включен). NAPI делает так чтобы получал управление по
программному прерыванию, не по прерыванию низкого уровня.

Если драйвер не поддерживает NAPI, можно попробовать увеличить объём
работы, который драйвер может делать в течение обработки прерывания.
Для 3c59x это делается с помощью опции max_interrupt_work (поэтому
нужно добавить опцию 'options 3c59x max_interrupt_work=10000' в файл
/etc/modules.conf). У других сетевых карт похожие опции.

> Работает ли DHCP через/поверх моста?

Мост передаёт DHCP-трафик (широковещательный) и ответы на него. Также
можно использовать DHCP для установки локального IP-адреса на
псевдо-интерфейс моста.

Одна из распространённых ошибок при использовании DHCP является
установка задержки передачи (forwarding delay) на порту коммутатора
равной 30 секунд. При такой задержке интерфейс когда он подключился к
мосту не может посылать через него данные в течении первых 30 секунд.
Причина в том, что при использовании моста в сложной топологии он
должен сначала обнаружить остальные мосты дабы не создавать петель.
Проблема была одной из причин создания протокола Rapid Spanning Tree
Protocol (RSTP).

Если мост используется в одиночку (т.е. поблизости нет мостов) можно
спокойно отключить задержку передачи (установить её равной 0) перед
тем как подключать интерфейс к мосту. После этого сразу же можно
вызывать dhclient: # brctl setfd br0 0 # brctl addif br0 eth0 # dhclient eth0

**Контактная информация**

В настоящий момент код сопровождается Стефаном Хеммингером (Stephen
Hemminger) <[shemminger@osdl.org.](mailto:shemminger@REMOVE-THIS-FAKE.osdl.org)> как для Linux ядра 2.4, так и
для 2.6. Ошибки и расширения обсуждаются списке рассылки "Bridge
mailing list" <[bridge@osdl.org.](mailto:bridge@REMOVE-THIS-FAKE.osdl.org)>. Список открыт для любых
интересующихся. Детали смотрите на web-интерфейсе
[http://lists.osdl.org/mailman/listinfo/bridge](http://lists.osdl.org/mailman/listinfo/bridge) к списку.

**Дополнительная информация**
_ [Ethernet VPN bridging](http://openvpn.sourceforge.net/bridge.html)
_ [Ebtables firewalling](http://ebtables.sourceforge.net/)
_ [Ethernet-bridge + netfilter HOWTO](http://www.tldp.org/HOWTO/Ethernet-Bridge-netfilter-HOWTO.html)
_ [Linux-bridge STP HOWTO](http://www.tldp.org/HOWTO/BRIDGE-STP-HOWTO/index.html)
_ [Spanning Tree Protocol на Wikipedia](http://en.wikipedia.org/wiki/Spanning_tree_protocol)
_ [Understanding Spanning-Tree Protocol (Cisco)](http://www.cisco.com/univercd/cc/td/doc/product/rtrmgmt/sw_ntman/cwsimain/cwsi2/cwsiug2/vlan2/stpapp.htm)
