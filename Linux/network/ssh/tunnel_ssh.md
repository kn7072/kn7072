# Практические советы, примеры и туннели SSH

[источник](https://habr.com/ru/articles/435546/)

Перевод

[Автор оригинала: Hacker Target](https://hackertarget.com/ssh-examples-tunnels/)

![](./tunnel_ssh_images/2a59f3de48cfcd86c7417558f89bf515_MD5.jpg)

Практические примеры [SSH](https://en.wikipedia.org/wiki/Secure_Shell), которые выведут на новый уровень ваши навыки удалённого системного администратора. Команды и советы помогут не только использовать `SSH`, но и более грамотно перемещаться по сети.

Знание нескольких трюков `ssh` полезно любому системному администратору, сетевому инженеру или специалисту по безопасности.

### Практические примеры SSH

1. [SSH socks-прокси]
2. [Туннель SSH]
3. [SSH-туннель на третий хост]
4. [Обратный SSH-туннель]
5. [Обратный прокси SSH]
6. [Установка VPN по SSH]
7. [Копирование ключа SSH]
8. [Удалённое выполнение команд]
9. [Удалённый перехват пакетов и просмотр в Wireshark]
10. [Копирование локальной папки на удалённый сервер по SSH]
11. [Удалённые приложения GUI с переадресацией SSH X11]
12. [Удалённое копирование файлов с помощью rsync и SSH]
13. [SSH через сеть Tor]
14. [SSH к инстансу EC2]
15. [Редактирование текстовых файлов с помощью VIM через ssh/scp]
16. [Монтирование удалённого SSH как локальной папки с SSHFS]
17. [Мультиплексирование SSH с помощью ControlPath]
18. [Потоковое видео по SSH с помощью VLC и SFTP]
19. [Двухфакторная аутентификация]
20. [Прыжки по хостам с SSH и -J]
21. [Блокировка попыток брутфорса SSH с помощью iptables]
22. [SSH Escape для изменения переадресации портов]

# Сначала основы

#### Разбор командной строки SSH

В следующем примере используются обычные параметры, часто встречающиеся при подключении к удалённому серверу `SSH`.

```
localhost:~$ ssh -v -p 22 -C neo@remoteserver
```

- `-v`: вывод отладочной информации особенно полезен при анализе проблем аутентификации. Можно использовать несколько раз для вывода дополнительной информации.
- `- p 22`: **порт для подключения** к удалённому серверу SSH. 22 не обязательно указывать, потому что это значение по умолчанию, но если протокол на каком-то другом порту, то указываем его с помощью параметра `-p`. Порт прослушивания указывается в файле `sshd_config` в формате `Port 2222`.
- `-C`: сжатие для соединения. Если у вас медленный канал или вы просматриваете много текста, это может ускорить связь.
- `neo@`: строка перед символом @ обозначает имя пользователя для аутентификации на удалённом сервере. Если не указать его, то по умолчанию будет использоваться имя пользователя учётной записи, в которую вы вошли в данный момент (~$ whoami). Пользователя также можно указать параметром `-l`.
- `remoteserver`: имя хоста, к которому подключается `ssh`, это может быть полное доменное имя, IP-адрес или любой хост в локальном файле hosts. Для подключения к хосту, который поддерживает и IPv4, и IPv6, можно добавить в командную строку параметр `-4` или `-6` для правильного резолвинга.

Все вышеперечисленные параметры являются необязательными, кроме `remoteserver`.

#### Использование файла конфигурации

Хотя многие знакомы с файлом `sshd_config`, есть ещё файл конфигурации клиента для команды `ssh`. Значение по умолчанию `~/.ssh/config`, но его можно определить как параметр для опции `-F`.

```
Host *     Port 2222Host remoteserver     HostName remoteserver.thematrix.io     User neo     Port 2112     IdentityFile /home/test/.ssh/remoteserver.private_key
```

В приведённом выше примерном файле конфигурации ssh две записи хоста. Первая обозначает все хосты, для всех применяется параметр конфигурации Port 2222. Вторая говорит, что для хоста **remoteserver** следует использовать другое имя пользователя, порт, FQDN и IdentityFile.

Файл конфигурации может сэкономить много времени на ввод символов, позволяя автоматически применять продвинутую конфигурацию при подключении к конкретным хостам.

#### Копирование файлов по SSH с помощью SCP

SSH-клиент поставляется с двумя другими очень удобными инструментами для копирования файлов по **зашифрованному ssh-соединению**. Ниже см. пример стандартного использования команд scp и sftp. Обратите внимание, что многие параметры для ssh применяются и в этих командах.

```
localhost:~$ scp mypic.png neo@remoteserver:/media/data/mypic_2.png
```

В этом примере файл **mypic.png** скопирован на **remoteserver** в папку **/media/data** и переименован в **mypic_2.png**.

Не забывайте о разнице в параметре порта. На этом попадаются многие, кто запускает `scp` из командной строки. Здесь параметр порта `-P`, а не `-p`, как в ssh-клиенте! Вы забудете, но не волнуйтесь, все забывают.

Для тех, кто знаком с консольным `ftp`, многие из команд похожи в `sftp`. Вы можете сделать **push**, **put** и **ls**, как сердце пожелает.

```
sftp neo@remoteserver
```

# Практические примеры

Во многих из этих примеров можно достичь результата разными методами. Как и во всех наших [учебниках](https://hackertarget.com/research/#tutorial) и примерах, предпочтение отдаётся практическим примерам, которые просто делают своё дело.

### 1. SSH socks-прокси

Функция SSH Proxy под номером 1 по уважительной причине. Она более мощная, чем многие предполагают, и даёт вам доступ к любой системе, к которой имеет доступ удалённый сервер, используя практически любое приложение. Клиент ssh может туннелировать трафик через прокси-сервер SOCKS одной простой командой. Важно понимать, что трафик к удалённым системам будет исходить от удалённого сервера, так будет указано в логах веб-сервера.

```
localhost:~$ ssh -D 8888 user@remoteserverlocalhost:~$ netstat -pan | grep 8888tcp        0      0 127.0.0.1:8888       0.0.0.0:*               LISTEN      23880/ssh
```

Здесь мы запускаем socks-прокси на TCP-порту 8888, вторая команда проверяет, что порт активен в режиме прослушивания. 127.0.0.1 указывает, что служба работает только на localhost. Мы можем применить немного другую команду для прослушивания всех интерфейсов, включая ethernet или wifi, это позволит другим приложениям (браузерам и т д.) в нашей сети подключаться к прокси-сервису через ssh socks-прокси.

```
localhost:~$ ssh -D 0.0.0.0:8888 user@remoteserver
```

Теперь можем настроить браузер для подключения к socks-прокси. В Firefox выберите **Настройки | Основные | Параметры сети**. Укажите IP-адрес и порт для подключения.

![](./tunnel_ssh_images/72a1d3ed8b1145dd364307b9ca614aef_MD5.png))

Обратите внимание на опцию в нижней части формы, чтобы DNS-запросы браузера тоже шли через прокси SOCKS. Если используете прокси-сервер для шифрования веб-трафика в локальной сети, то наверняка захотите выбрать эту опцию, чтобы DNS-запросы туннелировались через SSH-соединение.

#### Активация socks-прокси в Chrome

Запуск Chrome с определёнными параметрами командной строки активирует socks-прокси, а также туннелирование DNS-запросов из браузера. Доверяй, но проверяй. Используйте [tcpdump](https://hackertarget.com/tcpdump-examples/) для проверки, что DNS-запросы больше не видны.

```
localhost:~$ google-chrome --proxy-server="socks5://192.168.1.10:8888"
```

#### Использование других приложений с прокси

Имейте в виду, что многие другие приложения тоже могут использовать socks-прокси. Веб-браузер просто самое популярное из них. У некоторых приложений есть параметры конфигурации для активации прокси-сервера. Другим нужно немного помочь вспомогательной программой. Например, [proxychains](https://github.com/haad/proxychains) позволяет запустить через socks-прокси Microsoft RDP и др.

```
localhost:~$ proxychains rdesktop $RemoteWindowsServer
```

Параметры конфигурации socks-прокси задаются в файле конфигурации proxychains.

> Подсказка: если используете удалённый рабочий стол из Linux на Windows? Попробуйте клиент [FreeRDP](https://github.com/FreeRDP/FreeRDP). Это более современная реализация, чем `rdesktop`, с гораздо более плавным взаимодействием.

#### Вариант использования SSH через socks-прокси

Вы сидите в кафе или гостинице — и вынуждены использовать довольно ненадёжный WiFi. С ноутбука локально запускаем ssh-прокси и устанавливаем ssh-туннель в домашнюю сеть на локальный Rasberry Pi. Используя браузер или другие приложения, настроенные для socks-прокси, мы можем получить доступ к любым сетевым службам в нашей домашней сети или выйти в интернет через домашнее подключение. Всё между вашим ноутбуком и домашним сервером (через Wi-Fi и интернет до дома) зашифровано в туннеле SSH.

### 2. Туннель SSH (переадресация портов)

В простейшей форме SSH-туннель просто открывает порт в вашей локальной системе, который подключается к другому порту на другом конце туннеля.

```
localhost:~$ ssh  -L 9999:127.0.0.1:80 user@remoteserver
```

Разберём параметр `-L`. Его можно представить как локальную сторону прослушивания. Таким образом, в примере выше порт 9999 прослушивается на стороне localhost и переадресуется через порт 80 на remoteserver. Обратите внимание, что 127.0.0.1 относится к localhost на удалённом сервере!

Поднимемся на ступеньку. В следующем примере порты прослушивания связываются с другими узлами локальной сети.

```
localhost:~$ ssh  -L 0.0.0.0:9999:127.0.0.1:80 user@remoteserver
```

В этих примерах мы подключаемся к порту на веб-сервере, но это может быть прокси-сервер или любая другая служба TCP.

### 3. SSH-туннель на сторонний хост

Мы можем использовать те же параметры для подключения туннеля с удалённого сервера к другой службе, запущенной на третьей системе.

```
localhost:~$ ssh  -L 0.0.0.0:9999:10.10.10.10:80 user@remoteserver
```

В данном примере мы перенаправляем туннель от remoteserver к веб-серверу, работающему на 10.10.10.10. Трафик с remoteserver к 10.10.10.10 **уже не в SSH-туннеле**. Веб-сервер на 10.10.10.10 будет считать remoteserver источником веб-запросов.

### 4. Обратный SSH-туннель

Здесь настроим прослушивающий порт на удалённом сервере, который будет подключаться обратно к локальному порту на нашем localhost (или другой системе).

```
localhost:~$ ssh -v -R 0.0.0.0:1999:127.0.0.1:902 192.168.1.100 user@remoteserver
```

В этой SSH-сессии устанавливается соединение с порта 1999 на remoteserver к порту 902 на нашем локальном клиенте.

### 5. Обратный прокси SSH

В этом случае мы устанавливаем socks-прокси на нашем ssh-соединении, однако прокси слушает на удалённом конце сервера. Подключения к этому удалённому прокси теперь появляются из туннеля как трафик с нашего localhost.

```
localhost:~$ ssh -v -R 0.0.0.0:1999 192.168.1.100 user@remoteserver
```

#### Устранение проблем с удалёнными SSH-туннелями

Если у вас возникли проблемы с работой удалённых опций SSH, проверьте с помощью `netstat`, к каким ещё интерфейсам подключён порт прослушивания. Хотя мы в примерах указали 0.0.0.0, но если значение **GatewayPorts** в **sshd_config** установлено в значение **no**, то листенер будет привязан только к localhost (127.0.0.1).

> #### Предупреждение безопасности
>
> Обратите внимание, что при открытии туннелей и socks-прокси внутренние сетевые ресурсы могут быть доступны ненадёжным сетям (например, интернету!). Это может быть серьёзной угрозой безопасности, поэтому убедитесь, что вы понимаете, что представляет собой слушатель и к чему у него есть доступ.

### 6. Установка VPN по SSH

Общий термин среди спецов по методам атаки (пентестеры и проч.) — это «точка опоры в сети». После установления соединения в одной системе эта система становится шлюзом для дальнейшего доступа к сети. Точка опоры, которая позволяет двигаться вширь.

Для такой точки опоры мы можем использовать SSH-прокси и **proxychains**, однако есть некоторые ограничения. Например, не получится работать напрямую с сокетами, поэтому мы не сможем сканировать порты внутри сети через [Nmap](https://hackertarget.com/nmap-online-port-scanner/) `SYN`.

Используя этот более продвинутый вариант VPN, подключение снижается до **уровня 3**. Затем мы можем просто направить трафик через туннель, используя стандартную сетевую маршрутизацию.

Метод использует `ssh`, `iptables`, `tun interfaces` и маршрутизацию.

Сначала нужно задать эти параметры в `sshd_config`. Поскольку мы вносим изменения в интерфейсы и удалённой, и клиентской системы, нам **нужны права root с обеих сторон**.

```
PermitRootLogin yesPermitTunnel yes
```

Затем установим ssh-соединение, используя параметр, который запрашивает инициализацию tun-устройств.

```
localhost:~# ssh -v -w any root@remoteserver
```

Теперь у нас должно быть устройство tun при показе интерфейсов (`# ip a`). Следующий шаг добавит IP-адреса к туннельным интерфейсам.

Сторона клиента SSH:

```
localhost:~# ip addr add 10.10.10.2/32 peer 10.10.10.10 dev tun0localhost:~# ip tun0 up
```

Сторона сервера SSH:

```
remoteserver:~# ip addr add 10.10.10.10/32 peer 10.10.10.2 dev tun0remoteserver:~# ip tun0 up
```

Теперь у нас прямой маршрут к другому хосту (`route -n` и `ping 10.10.10.10`).

Можно маршрутизировать любую подсеть через хост на другой стороне.

```
localhost:~# route add -net 10.10.10.0 netmask 255.255.255.0 dev tun0
```

На удалённой стороне необходимо включить `ip_forward` и `iptables`.

```
remoteserver:~# echo 1 > /proc/sys/net/ipv4/ip_forwardremoteserver:~# iptables -t nat -A POSTROUTING -s 10.10.10.2 -o enp7s0 -j MASQUERADE
```

Бум! **VPN через туннель SSH на сетевом уровне 3**. Вот это уже победа.

Если возникают какие-то проблемы, используйте [tcpdump](https://hackertarget.com/tcpdump-examples/) и `ping`, чтобы установить причину. Поскольку мы играем на уровне 3, то наши пакеты icmp пойдут через этот туннель.

### 7. Копирование ключа SSH (ssh-copy-id)

Тут есть несколько способов, но эта команда экономит время, чтобы не копировать файлы вручную. Она просто копирует ~/.ssh/id_rsa.pub (или ключ по умолчанию) с вашей системы в `~/.ssh/authorized_keys` на удалённом сервере.

```
localhost:~$ ssh-copy-id user@remoteserver
```

### 8. Удалённое выполнение команд (неинтерактивно)

Команду `ssh` можно связать с другими командам для обычного удобного интерфейса. Просто добавьте команду, которую хотите запустить на удалённом хосте, в качестве последнего параметра в кавычках.

```
localhost:~$ ssh remoteserver "cat /var/log/nginx/access.log" | grep badstuff.php
```

В данном примере `grep` выполняется на локальной системе после того, как лог скачался по ssh-каналу. Если файл большой, удобнее запустить `grep` на удалённой стороне, просто заключив обе команды в двойные кавычки.

Другой пример выполняет ту же самую функцию, что и `ssh-copy-id` из примера 7.

```
localhost:~$ cat ~/.ssh/id_rsa.pub | ssh remoteserver 'cat >> .ssh/authorized_keys'
```

### 9. Удалённый перехват пакетов и просмотр в Wireshark

Я взял один из наших [примеров по tcpdump](https://hackertarget.com/tcpdump-examples/). Используйте его для удалённого перехвата пакетов с выдачей результата непосредственно в GUI локального Wireshark.

```
:~$ ssh root@remoteserver 'tcpdump -c 1000 -nn -w - not port 22' | wireshark -k -i -
```

### 10. Копирование локальной папки на удалённый сервер по SSH

Красивый трюк, который сжимает папку с помощью `bzip2` (это параметр -j в команде `tar`), а затем извлекает поток `bzip2` на другой стороне, создавая на удалённом сервере дубликат папки.

```
localhost:~$ tar -cvj /datafolder | ssh remoteserver "tar -xj -C /datafolder"
```

### 11. Удалённые приложения GUI с переадресацией SSH X11

Если на клиенте и удалённом сервере установлены «иксы», то можно удалённо выполнить команду GUI, с окном на вашем локальном рабочем столе. Эта функция существует давным давно, но по-прежнему очень полезна. Запустите удалённый веб-браузер или даже консоль VMWawre Workstation, как я делаю в этом примере.

```
localhost:~$ ssh -X remoteserver vmware
```

Требуется строка `X11Forwarding yes` в файле `sshd_config`.

### 12. Удалённое копирование файлов с помощью rsync и SSH

`rsync` во многом удобнее `scp`, если требуется периодическое резервное копирование каталога, большого количества файлов или очень больших файлов. Здесь есть функция восстановления после сбоя передачи и копирования только изменённых файлов, что сохраняет трафик и время.

В этом примере используется сжатие `gzip` (-z) и режим архивирования (-a), который включает рекурсивное копирование.

```
:~$ rsync -az /home/testuser/data remoteserver:backup/
```

### 13. SSH через сеть Tor

Анонимная сеть Tor может туннелировать SSH-трафик с помощью команды `torsocks`. Следующая команда прокинет ssh-прокси через Tor.

```
localhost:~$ torsocks ssh myuntracableuser@remoteserver
```

[Torsocks](https://github.com/dgoulet/torsocks) будет использовать для прокси порт 9050 на localhost. Как всегда при использовании Tor необходимо серьёзно проверять, какой трафик туннелируется и другие проблемы операционной безопасности (opsec). **Куда идут ваши DNS-запросы?**

### 14. SSH к инстансу EC2

Для подключения к инстансу EC2 необходим закрытый ключ. Скачайте его (расширение .pem) из панели управления Amazon EC2 и измените разрешения (`chmod 400 my-ec2-ssh-key.pem`). Храните ключ в надёжном месте или поместите его в свою папку `~/.ssh/`.

```
localhost:~$ ssh -i ~/.ssh/my-ec2-key.pem ubuntu@my-ec2-public
```

Параметр **-i** просто указывает ssh-клиенту использовать этот ключ. Файл `~/.ssh/config` идеально подходит для автоматической настройки использования ключа при подключении к хосту ec2.

```
Host my-ec2-public   Hostname ec2???.compute-1.amazonaws.com   User ubuntu   IdentityFile ~/.ssh/my-ec2-key.pem
```

### 15. Редактирование текстовых файлов с помощью VIM через ssh/scp

Для всех любителей `vim` этот совет сэкономит немного времени. С помощью `vim` файлы редактируются по scp одной командой. Этот метод просто создаёт файл локально в `/tmp`, а затем копирует его обратно, как только мы его сохранили из `vim`.

```
localhost:~$ vim scp://user@remoteserver//etc/hosts
```

Примечание: формат немного отличается от обычного `scp`. После хоста у нас двойной `//`. Это ссылка на абсолютный путь. Один слэш будет означать путь относительно домашней папки `users`.

```
**warning** (netrw) cannot determine method (format: protocol://[user@]hostname[:port]/[path])
```

Если увидите такую ошибку, дважды проверьте формат команды. Обычно это означает синтаксическую ошибку.

### 16. Монтирование удалённого SSH как локальной папки с SSHFS

При помощи `sshfs` — клиента файловой системы `ssh` — мы можем подключить локальный каталог к удалённому местоположению со всеми взаимодействиями файлов в зашифрованном сеансе `ssh`.

```
localhost:~$ apt install sshfs
```

На Ubuntu и Debian установим пакет `sshfs`, а затем просто приимонтируем удалённое расположение к нашей системе.

```
localhost:~$ sshfs user@remoteserver:/media/data ~/data/
```

### 17. Мультиплексирование SSH с помощью ControlPath

По умолчанию при наличии существующего подключения к удалённому серверу с помощью `ssh` второе подключение с помощью `ssh` или `scp` устанавливает новый сеанс с дополнительной аутентификацией. Опция `ControlPath` позволяет использовать существующий сеанс для всех последующих соединений. Это значительно ускорит процесс: эффект заметен даже в локальной сети, а тем более при подключении к удалённым ресурсам.

```
Host remoteserver        HostName remoteserver.example.org        ControlMaster auto        ControlPath ~/.ssh/control/%r@%h:%p        ControlPersist 10m
```

ControlPath указывает сокет для проверки новыми соединениями на предмет наличия активной сессии `ssh`. Последняя опция означает, что даже после выхода из консоли существующий сеанс останется открытым 10 минут, так что в течение этого времени вы сможете повторно подключиться по существующему сокету. Для дополнительной информации смотрите справку `ssh_config man`.

### 18. Потоковое видео по SSH с помощью VLC и SFTP

Даже давние пользователи `ssh` и `vlc` (Video Lan Client) не всегда знают об этой удобной опции, когда очень нужно посмотреть видео по сети. В настройках **File | Open Network Stream** программы `vlc` можно ввести местоположение как `sftp://`. Если требуется пароль, появится запрос.

```
sftp://remoteserver//media/uploads/myvideo.mkv
```

### 19. Двухфакторная аутентификация

Такая же двухфакторная аутентификация, как у вашего банковского счёта или учётной записи Google, применима к сервису SSH.

Конечно, `ssh` изначально имеет функцию двухфакторной аутентификации, под которой подразумеваются пароль и ключ SSH. Преимущество аппаратного токена или приложения Google Authenticator заключается в том, что это обычно другое физическое устройство.

См. наше 8-минутное руководство по [использованию Google Authenticator и SSH](https://hackertarget.com/ssh-two-factor-google-authenticator/).

### 20. Прыжки по хостам с ssh и -J

Если из-за сегментации сети приходится переходить через несколько хостов ssh, чтобы добраться до конечной сети назначения, вам сэкономит время ярлык -J.

```
localhost:~$ ssh -J host1,host2,host3 user@host4.internal
```

Здесь главное понимать, что это не аналогично команде `ssh host1`, затем `user@host1:~$ ssh host2` и т. д. Параметр -J хитро использует переадресацию, чтобы localhost устанавливал сеанс со следующим хостом в цепочке. Таким образом, в приведённом выше примере наш localhost аутентифицируется на host4. То есть используются наши ключи localhost, а сеанс от localhost до host4 полностью зашифрован.

Для такой возможности в `ssh_config` укажите опцию конфигурации **ProxyJump**. Если регулярно приходится переходить через несколько хостов, то автоматизация через конфиг сэкономит массу времени.

### 21. Блокировка попыток брутфорса SSH с помощью iptables

Любой, кто управлял сервисом SSH и просматривал логи, знает о количестве попыток брутфорса, которые происходят каждый час каждый день. Быстрый способ уменьшить шум в логах — перенести SSH на нестандартный порт. Внесите изменения в файл `sshd_config` с помощью параметра конфигурации **Port##**.

С помощью `iptables` тоже можно легко блокировать попытки подключения к порту по достижении определённого порога. Простой способ сделать это — использовать [OSSEC](https://hackertarget.com/enable-ossec-active-response/), поскольку он не только блокирует SSH, но выполняет кучу других мер по обнаружению вторжений на базе имени хоста (HIDS).

### 22. SSH Escape для изменения переадресации портов

И наш последний пример `ssh` предназначен для изменения переадресации портов на лету в рамках существующего сеанса `ssh`. Представьте такой сценарий. Вы глубоко в сети; возможно, прыгнули через полдюжины хостов и вам нужен локальный порт на рабочей станции, который перенаправлен на Microsoft SMB старой системы Windows 2003 (кто-нибудь помнит ms08-67?).

Нажав `enter`, попробуйте ввести в консоли `~C`. Это управляющая последовательность в сессии, позволяющая вносить изменения в существующее соединение.

```
localhost:~$ ~Cssh> -hCommands:      -L[bind_address:]port:host:hostport    Request local forward      -R[bind_address:]port:host:hostport    Request remote forward      -D[bind_address:]port                  Request dynamic forward      -KL[bind_address:]port                 Cancel local forward      -KR[bind_address:]port                 Cancel remote forward      -KD[bind_address:]port                 Cancel dynamic forwardssh> -L 1445:remote-win2k3:445Forwarding port.
```

Здесь вы можете увидеть, что мы переадресовали наш локальный порт 1445 на хост Windows 2003, который нашли во внутренней сети. Теперь просто запустите `msfconsole`, и можно идти дальше (предполагая, что вы планируете использовать этот хост).

# Завершение

Эти примеры, советы и команды `ssh` должны дать отправную точку; дополнительная информация о каждой из команд и возможностей доступна на справочных страницах (`man ssh`, `man ssh_config`, `man sshd_config`).

Меня всегда очаровывала возможность обращаться к системам и выполнять команды в любой точке мира. Развивая свои навыки по работе с инструментами вроде `ssh` вы станете более эффективным в любой игре, в какую играете.
