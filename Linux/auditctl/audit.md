[источник](https://yar4e-it.blogspot.com/2015/04/linux-inotify.html?m=1)
Ниже следует статья «[Пингвин под колпаком: Аудит системных событий в Linux](https://xakep.ru/2011/03/30/54897/)» из журнала «Хакер», отлично описывающая систему аудита Linux. После статьи идут мои дополнения по практическому использованию аудита, которых в этой статье, на мой взгляд, не достаёт.

Грамотная после-установочная настройка Linux-дистрибутива – лишь первый шаг на пути к безопасности и стабильности. Чтобы операционная система и дальше продолжала отвечать этим требованиям, придется приучить себя к постоянному слежению за ее состоянием. Этого можно достичь с помощью мониторинга и анализа лог-файлов, однако получение полного контроля над системой возможно только с помощью аудита системных событий.

Перед тем как перейти к основной части статьи, постараемся разобраться с тем, что же все-таки представляет собой системный аудит (или аудит системных событий). По самой своей сути это не что иное, как постоянное и подробное протоколирование любых событий, происходящих в операционной системе. Аудиту могут быть подвержены такие события, как чтение/запись файлов, выполнение входа в ОС, запуск и остановка приложений, инициация сетевого соединения и многое, многое другое. Linux, как и любая другая современная серверная ОС, включает в себя все необходимые инструменты для проведения аудита системы, однако разобраться в них с наскоку не так-то просто.

**Система аудита ядра 2.6**
 
Начиная с версии 2.6, ядро Linux включает в себя подсистему, специально разработанную для проведения аудита. Она позволяет вести слежение за такими системными событиями, как:
  
- Запуск и завершение работы системы (перезагрузка, остановка);
- Чтение/запись или изменение прав доступа к файлам;
- Инициация сетевого соединения или изменение сетевых настроек;
- Изменение информации о пользователе или группе;
- Изменение даты и времени;
- Запуск и остановка приложений;
- Выполнение системных вызовов.
    
На деле этот список гораздо длиннее, но другие типы событий не представляют для нас практического интереса. Кроме самого факта возникновения события, система аудита представляет такую информацию, как дата и время возникновения события, отвественность пользователя за событие, тип события и его успешность. Сама по себе она способна лишь сообщать о произошедшем событии, тогда как процесс журналирования возлагается на плечи демона auditd.
 
**Установка**

Демон auditd доступен в любом современном Linux-дистрибутиве и может быть установлен с помощью стандартного менеджера пакетов. Например, чтобы установить auditd в Debian/Ubuntu, достаточно выполнить следующую команду:

> `$ sudo apt-get install auditd`

Кроме самого демона, вместе с пакетом будут установлены три подсобные утилиты, используемые для управления системой аудита и поиска записей в журнальных файлах:
 

- auditctl – утилита, управляющая поведением системы аудита. Позволяет узнать текущее состояние системы, добавить или удалить правила;
    
- autrace – аудит событий, порождаемых указанным процессом (аналог strace);
    
- ausearch – команда, позволяющая производить поиск событий в журнальных файлах;
    
- aureport – утилита, генерирующая суммарные отчеты о работе системы аудита;
    
  
По умолчанию система аудита находится в спящем состоянии и не реагирует ни на какие события (ты можешь убедиться в этом, выполнив команду «sudo auditctl -l»). Чтобы заставить систему сообщать нам подробности каких-либо событий, необходимо добавить правила. Но чтобы понять, как их составлять, придется разобраться с тем, как работает подсистема аудита ядра Linux.

**Аудит системных событий**

Ни одно событие в любой операционной системе не может произойти без использования системных вызовов ядра. Запуск нового процесса, открытие файлов и работа с ними, запрос времени или типа ОС, обращение к оборудованию, создание сетевого соединения, вывод информации на экран – все эти операции производятся с помощью обращения к функциям ядра операционной системы, для краткости называемых системными вызовами. Если приложение не прибегает в своей работе к вызовам ядра, оно оказывается замкнутым в самом себе и просто не способно к какому-либо взаимодействию со своим окружением, не говоря уже о пользователе. Следовательно, чтобы отследить любое системное событие, достаточно просто перехватывать все обращения к системным вызовам.

Именно это делает подсистема аудита. Она устанавливает триггеры до и после всех функций, ответственных за обработку системных вызовов, и ждет. Когда происходит системный вызов, триггер срабатывает, подсистема аудита получает всю информацию о вызове и его контексте, передает ее демону auditd и отдает дальнейшее управление функции, обрабатывающей системный вызов. После ее завершения срабатывает «выходной» триггер, и вся информация о системном вызове вновь поступает к подсистеме аудита и демону auditd.

Естественно, держать все эти триггеры в активном состоянии все время работы ОС накладно и слишком избыточно (только во время старта приложение может выполнить несколько тысяч системных вызовов и для полного анализа журнала аудита придется убить уйму времени). Поэтому по умолчанию триггеры отключены и могут быть выборочно активированы с помощью правил, которые задают имя системного вызова, его успешность, пользователя, от имени которого произошел вызов и т. д.
 
Благодаря такой нехитрой схеме, системный администратор может вести наблюдение за любым аспектом работы операционной системы (кроме, конечно же, тех событий, которые вызваны компонентами самого ядра). Поэтому, если в системе происходят какие-либо подозрительные действия, вызванные работой взломщика или вредоносного ПО, с помощью системного аудита не составит труда их выявить и найти виновного.

**Правила аудита**

Для создания, удаления и модификации правил аудита предназначена утилита auditctl. Есть три основных опции, которые принимает эта команда:
  
- -a – добавить правило в список;
- -d – удалить правило из списка;
- -D – удалить все правила;
- -l – вывести список заданных правил.
    
Если ты сейчас выполнишь команду «auditctl -l» от имени администратора, то, скорее всего, увидишь «No rules», а это значит, что ни одного правила аудита еще не существует. Для добавления правил используется следующая форма записи команды auditctl:

> `# auditctl -a список,действие -S имя_системного_вызова -F фильтры`

Здесь список – это список событий, в который следует добавить правило. Всего существует пять списков:

- task – события, связанные с созданием процессов;
- entry – события, происходящие при входе в системный вызов;
- exit – события, происходящие во время выхода из системного вызова;
- user – события, использующие параметры пользовательского пространства, такие как uid, pid и gid;
- exclude – используется для исключения событий.

Не беспокойся, если смысл списков кажется тебе непонятным. По сути, это всего лишь фильтры, которые позволяют сделать правила более точными. На деле из них используются только entry и exit, которые позволяют зарегистрировать либо сам факт обращения к системному вызову, либо его успешную отработку.
  
Второй параметр опции – ‘-a’ – это действие, которое должно произойти в ответ на возникшее событие. Их всего два: never и always. В первом случае события не записываются в журнал событий, во втором – записываются.
  
Далее указывается опция ‘-S’, которая задает имя системного вызова, при обращении к которому должен срабатывать триггер (например, open, close, exit, и т.д.). Вместо имени может быть использовано числовое значение.
  
Необязательная опция ‘-F’ используется для указания дополнительных параметров фильтрации события. Например, если мы хотим вести журнал событий, связанных с использованием системного вызова open(), но при этом желаем регистрировать только обращения к файлам каталога /etc, то должны использовать следующее правило:

> `# auditctl -a exit,always -S open -F path=/etc/`

Чтобы еще более сузить круг поисков, сделаем так, чтобы регистрировались только те события, при которых файл открывается только на запись и изменение атрибутов:

> `# auditctl -a exit,always -S open -F path=/etc/ -F perm=aw`

Здесь ‘a’ – изменение атрибута (то есть attribute change), а ‘w’ – запись (то есть write). Также можно использовать ‘r’ – чтение (read) и ‘x’ – исполнение (execute). Другие полезные фильтры включают в себя: pid – события, порождаемые указанным процессом, apid – события, порождаемые указанным пользователем, success – проверка на то, был ли системный вызов успешным, a1, a2, a3, a4 – первые четыре аргумента системного вызова. Фильтр key используется для указания так называемого ключа поиска, который может быть использован для поиска всех событий, связанных с этим ключом. Количество возможных фильтров достаточно велико, их полный список можно найти в man-странице auditctl.
  
Вообще, для слежения за файлами в auditctl предусмотрен специальный синтаксис, при котором опцию ‘-S’ можно опустить. Например, описанное выше правило может быть задано следующим образом (здесь опция ‘-p’ – это эквивалент фильтра perm):

> `# auditctl -a exit,always -F dir=/etc/ -F perm=wa`

Или используя более короткую форму (здесь оцпия ‘-p’ – это эквивалент фильтра perm, а ‘-k’ – фильтра key):

> `# auditctl -w /etc/ -p wa -k access_etc`

Таким же образом может быть установлена «слежка» за любым индивидуальным файлом:

> `# auditctl -w /etc/passwd -p wa`

**Конфигурационные файлы**
  
Правила не обязательно задавать, используя командную строку. Во время старта демон auditd читает два файла: /etc/audit/auditd.conf и /etc/audit/audit.rules (в некоторых дистрибутивах они могут находиться прямо в /etc). Первый описывает конфигурацию демона и содержит такие опции, как имя журнала, его формат, частота обновления и другие параметры. Нет смысла их изменять, разработчики дистрибутива уже позаботились о грамотной настройке.
 
Второй файл содержит правила аудита в формате auditctl, поэтому все, что нужно сделать, чтобы получить правило, пригодное для записи в этот файл – просто опустить имя команды. Например:

> `-w /etc/passwd -p wa`

В начале файла обычно размещаются несколько мета-правил, задающих конфигурацию и очищающих правила:

> `# Удаляем все правила из всех списков   
> -D`
>   
> `# Указываем количество буферов, хранящих сообщения аудита   
> -b 8192`
> 
> `# Что делать в чрезвычайной ситуации (например, если все буферы будут заполнены)`
> 
> `0 – ничего не делать`
> 
> `1 – поместить сообщение в dmesg`
> 
> `2 – отправить ядро в панику (kernel panic)`
> 
> `-f 1`
 
Далее можно разместить свои правила.

**Примеры правил**

Первое, что следует сделать – настроить наблюдение за всеми конфигурационными и лог-файлами системы аудита. Если взломщик сможет компрометировать один из них, он наверняка изменит поведение демона, и мы просто не сможем найти его следы.

> **# vi /etc/audit/audit.rules**
> 
> `# Наблюдение за конфигурационными файлами   
> -w /etc/audit/auditd.conf -p wa   -w /etc/audit/audit.rules -p wa   -w /etc/libaudit.conf -p wa   -w /etc/default/auditd -p wa`
> 
> `# Наблюдение за журнальными файлами   
> -w /var/log/audit/   -w /var/log/audit/audit.log`

Далее установим наблюдение за наиболее важными системными конфигурационными файлами. Изменение хотя бы одного из них может привести к открытию дыры в безопасности системы, чего допустить нельзя. Обрати внимание, что некоторые файлы актуальны только для дистрибутивов Debian/Ubuntu!

> **# vi /etc/audit/audit.rules**
>    
> `# Настройки и задания at   
> -w /var/spool/at   -w /etc/at.allow   -w /etc/at.deny`

> `# Задания cron   
> -w /etc/cron.allow -p wa   -w /etc/cron.deny -p wa   -w /etc/cron.d/ -p wa   -w /etc/cron.daily/ -p wa   -w /etc/cron.hourly/ -p wa   -w /etc/cron.monthly/ -p wa   -w /etc/cron.weekly/ -p wa   -w /etc/crontab -p wa   -w /var/spool/cron/root`
> 
> `# Файлы паролей и групп   
> -w /etc/group -p wa   -w /etc/passwd -p wa   -w /etc/shadow`
>    
> `# Конфигурационные и журнальные файлы входа в систему   
> -w /etc/login.defs -p wa   -w /etc/securetty   -w /var/log/faillog   -w /var/log/lastlog`
> 
> `# Список и имена хостов   
> -w /etc/hosts -p wa`
> 
> `# Стартовые скрипты демонов   
> -w /etc/init.d/   -w /etc/init.d/auditd -p wa`
> 
> `# Пути поиска библиотек   
> -w /etc/ld.so.conf.d   -w /etc/ld.so.conf -p wa`
> 
> `# Настройки времени   
> -w /etc/localtime -p wa`
> 
> `# Системные переменные   
> -w /etc/sysctl.conf -p wa`
> 
> `# Правила загрузки модулей   
> -w /etc/modprobe.d/`
> 
> `# Модули системы PAM   
> -w /etc/pam.d/`
> 
> `# Настройки сервера SSH   
> -w /etc/ssh/sshd_config`


Настроим наблюдение за всеми системными вызовами, которые могут угрожать безопасности системы. Эти правила следует применять только в случае особой необходимости, они создадут высокую нагрузку на систему аудита и приведут к существенному разрастанию журнальных файлов, однако взамен ты получишь тотальный контроль над системой и сможешь легко выявить малейшее нарушение ее работы.

> **# vi /etc/audit/audit.rules**
> 
> `# Изменение прав доступа к файлам   
> -a entry,always -S chmod -S fchmod -S chown -S chown32 -S fchown -S fchown32 -S lchown -S lchown32`
> 
> `# Создание, открытие или изменение размеров файлов   
> -a entry,always -S creat -S open -S truncate -S truncate64 -S ftruncate -S ftruncate64`
> 
> `# Создание и удаление каталогов   
> -a entry,always -S mkdir -S rmdir`
> 
> `# Удаление или создание ссылок   
> -a entry,always -S unlink -S rename -S link -S symlink`
> 
> `# Изменение расширенных атрибутов файлов   
> -a entry,always -S setxattr   -a entry,always -S lsetxattr   -a entry,always -S fsetxattr   -a entry,always -S removexattr   -a entry,always -S lremovexattr   -a entry,always -S fremovexattr`
> 
> `# Создание файлов устройств   
> -a entry,always -S mknod`
> 
> `# Монтирование файловых систем   
> -a entry,always -S mount -S umount -S umount2`
> 
> `# Использование системного вызова ptrace для отладки процессов   
> -a entry,always -S ptrace`


**Анализ журнальных файлов**

Журнальные файлы, создаваемые демоном auditd в каталоге /var/log/audit, не предназначены для чтения человеком, но хорошо подходят для анализа с помощью специальных утилит, устанавливаемых вместе с самим демоном. Самая важная из них – утилита aureport, генерирующая отчеты из лог-файлов. Вызвав ее без аргументов, мы узнаем общую статистику использования системы, включая такие параметры, как количество входов и выходов из системы, открытых терминалов, системных вызовов и т.д. Эта информация малоинтересна, поэтому лучше запросить более детальный отчет. Например, запустив команду с флагом ‘-f’, мы получим список файлов, к которым происходил доступ:

> `$ sudo aureport -f`

Скорее всего вывод будет слишком длинным, но его можно сократить с помощью запроса информации только за определенный период времени (аргумент ‘–end’ не обязателен):

> `$ sudo aureport -f --start 08/20/10 12:00 --end 08/20/10 13:00`

Кроме числового значения времени можно использовать следующие специальные сокращения: now (сейчас), recent (десять минут назад), today (начиная с полуночи), yesterday (вчерашние сутки), this-week (неделя), this-month (месяц) или this-year (год). Вывод команды разбит на несколько столбцов, которые имеют следующие значения (слева направо):

1. Просто числовой индекс;
2. Дата возникновения события;
3. Время возникновения события;
4. Имя файла;
5. Номер системного вызова (чтобы увидеть его имя, используй флаг ‘-i’);
6. Успешность системного вызова (yes или no);
7. Имя процесса, вызвавшего событие;
8. Audit UID (AUID). О нем читай ниже;
9. Номер события.
    

Вывод этой команды также можно существенно сократить, если указать флаг ‘–summary’, который заставляет aureport выводить не все случаи доступа к файлом, а только их общее количество по отношению к каждому из файлов:

> `$ sudo aureport -f -i --start recent --summary`

Вывод команды будет разбит на две колонки, первая из которых отражает количество попыток доступа к файлу (успешных или нет), а вторая – его имя. Просматривая суммарный отчет использования файлов и заметив подозрительную попытку доступа к одному из системных/скрытых/личных файлов, можно вновь вызвать aureport, чтобы найти процесс, который произвел эту попытку:

> `$ sudo aureport -f -i --start today | grep /etc/passwd`

Получив список всех попыток доступа и номера событий, каждое из них можно проанализировать индивидуально с помощью утилиты ausearch:

> `$ sudo auserch -a номер_события`

Также ausearch можно использовать для поиска событий по именам системных вызовов:

> `$ sudo ausearch -sc ptrace -i`

Идентификаторам пользователей:

> `$ sudo ausearch -ui 2010`

Именам исполняемых файлов:

> `$ sudo ausearch -x /usr/bin/nmap`

Имени терминала:

> `$ sudo ausearch -tm pts/0`

Именам демонов:

> `$ sudo ausearch -tm cron`

Или ключам поиска:

> `$ sudo auserch -k etc_access`

Вывод ausearch также может быть сокращен с помощью использования временных промежутков, наподобие тех, что мы использовали при вызове aureport. Сам aureport позволяет генерировать отчеты не только по использованию файлов, но и многих других типов событий, как, например, системные вызовы (флаг ‘-s’), попытки аутентификации (флаг ‘-au’) , успешные логины (флаг ‘-l’), модификации аккаунта (флаг ‘-m’) и многих других (полный список смотри в man-странице). Отчеты можно получать только для событий, завершившихся неудачно (флаг ‘–failed’).

**AUID и PAM**

Во время своей работы в системе пользователь может использовать команды su или sudo для изменения своего системного идентификатора (UID), из-за чего процесс отслеживания его деятельности существенно усложняется. Чтобы обойти эту проблему система аудита использует так называемые Audit UID (AUID), которые закрепляются за каждым пользователем во время его входа в систему и остаются неизменными даже несмотря на смену пользователем своего UID с помощью su или sudo. Однако, по умолчанию функция присваивания AUID отключена (именно поэтому восьмой столбец вывода aureport всегда содержит значение -1), и, чтобы ее активировать, необходимо отредактировать некоторые конфигурационные файлы PAM. Для этого открой файл /etc/pam.d/login и добавь строку «session required pam_loginuid.so» перед строкой «session include common-session». Таким же образом измени конфигурационные файлы /etc/pam.d/sshd, /etc/pam.d/gdm (kdm, если ты используешь среду KDE), /etc/pam.d/crond и /etc/pam.d/atd.

**Выводы**

Система аудита – достаточно низкоуровневый компонент Linux, который требует глубоких знаний ОС для своей настройки и анализа журнальных файлов. Однако, разобравшись в нем, ты получишь мощнейший инструмент слежения за системой, который поможет обнаружить аномалии в поведении системы и найти их виновника.

**WARNING**

Чтобы изменения, внесенные тобой в конфигурационные файлы демона auditd, вступили в силу, необходимо перезагрузить демон с помощью команды «**etc/init.d/auditd restart**».

**Моё дополнение к статье.**

При задании временного интервала утилитам aureport и ausearch, нужно учитывать «не русский» формат даты, при котором сначала идёт месяц, а не число а в качестве разделителя используется слеш: м/ч/г или 1/20/15, что равняется 20 января 2015 года.

С помощью опции -au или —auth, утилиты aureport, можно просмотреть все попытки авторизации всех процессов в системе.

А с помощью опции -l или —login, aureport выдаст только попытки авторизации пользователей, как локальные, так и удалённые.

Опция -f или —file, утилиты ausearch, совместно с указанием имени файла, отображает события, относящиеся только к конкретному файлу.

Опция -n или —node утилит ausearch и aureport, с указанием после неё имени узла, позволяет производить поиск событий, относящихся только к заданному узлу.

При указании директории, в качестве наблюдаемого объекта в файле audit.rules, наблюдение производится рекурсивно. Все создаваемые файлы внутри этой директории сразу же вступают в ряды наблюдаемых.

При наблюдении за системными вызовами, нужно помнить, что это существенно сказывается на производительности системы. Для оптимизации быстродействия, нужно объединять несколько правил в одно. Например:

> -a exit,always -S open -F success=0
> 
> -a exit,always -S truncate -F success=0

может быть записано как одно правило:

> -a exit,always -S open -S truncate -F success=0

Так же стоит объективно оценивать необходимость наблюдения системных вызовов во всей файловой системе. Чем меньше файлов участвуют в аудите, тем быстрее работает система, поэтому стоит указывать конкретные директории, в которых его нужно применять:

> -a exit,always -S open -S truncate -F dir=/etc -F success=0

**Настройка клиент-серверного журналирования.**

На сервере:

- Задать имя узла в /etc/audit/auditd.conf. По имени узла будет производиться фильтрация журналов на сервере аудита. За имя узла отвечают две строки: name — заданное пользователем имя узла (используется только если строка name_format = USER) и name_format — формат имени, по умолчанию значение NONE — имя узла не добавляется в журнал аудита, HOSTNAME — имя узла, полученное с помощью системного вызова gethostname, FQD — имя узла, получается с помощью dns, NUMERIC — именем узла является ip адрес узла, полученный от dns, USER — имя узла задаётся вручную строкой name =
    
- Задать максимальный размер файл журнала в /etc/audit/auditd.conf и какое действие предпринимать при достижении этого значения. В строке max_log_file =, задаётся размер журнала. Значением является целое число, единица измерения — мегабайт. В строке max_log_file_action =, задаётся действие, которое должен предпринимать демон, при достижении журналом заданного выше размера. Так как информация в этом журнале чрезвычайно важна для нас, то мы выбираем из двух опций — IGNORE, то есть не предпринимать никаких действий (и соответственно заниматься резервным копированием и очищением журнала самостоятельно) и KEEP_LOGS, то есть ротировать, но при этом не удалять старые журналы. KEEP_LOGS на мой взгляд предпочтительнее.
    
- Задать порт, на который удалённые клиенты могут отправлять данные аудита и размер очереди. Порт задаётся строкой tcp_listen_port и может иметь значение от 1 до 65535. Очередь задаётся строкой tcp_listen_queue. Значение не должно быть слишком маленьким, иначе появляется вероятность того, что при переполнении очереди входящие подключения будут отвергнуты до момента её освобождения (что не факт, если значение мало, а поток данных и клиентов велик). По умолчанию имеет значение 5.
    
- Опционально, можно задать с каких клиентских портов разрешен приём данных. За это отвечает строка tcp_client_ports и значение может быть как одним числом, так и двумя, разделёнными дефисом, означая интервал. По умолчанию разрешен приём со всех клиентских портов.

На клиентах:

- Задать имя узла в /etc/audisp/audispd.conf. По имени узла будет производиться фильтрация журналов на сервере аудита. За имя узла отвечают две строки: name — заданное пользователем имя узла (используется только если строка name_format = USER) и name_format — формат имени, по умолчанию значение NONE — имя узла не добавляется в журнал аудита, HOSTNAME — имя узла, полученное с помощью системного вызова gethostname, FQD — имя узла, получается с помощью dns, NUMERIC — именем узла является ip адрес узла, полученный от dns, USER — имя узла задаётся вручную строкой name =
    
- Задать адрес и порт удалённого сервера аудита в файле /etc/audisp/audisp-remote.conf. Адрес задаётся в строке remote_server, а порт в строке port.
    
- Опционально можно задать с какого локального порта будут посылаться данные на удалённый сервер аудита, за это отвечает строка local_port. Если задано, то так же на стороне сервера этот порт нужно указать в строке tcp_client_ports файла /etc/audit/auditd.conf, как было описано выше. По умолчанию не задано.
    
- Задать режим и формат журналирования. За режим отвечает строка mode с двумя возможными значениями — immediate, когда данные сразу отсылаются на удалённый сервер и forward, когда данные сначала сохраняются на диск, а потом уже предпринимается попытка сослать их на удалённый сервер и если тот не отвечает, то данные ставятся в очередь и посылаются при первой же возможности. Forward предпочтительнее, так как более надёжен. При использовании значения forward, строка выбора формата format должна иметь значение managed. За выбор формата, в котором будут отправляться сообщения ответственна строка format, как уже упоминалось ранее. Значений может быть два — ascii, когда данные отправляются в простом текстовом формате и managed, когда к этим данным добавляется служебная информация, повышающая надёжность передачи данных. По умолчанию используется значение managed.
    
- Создать папку в spooler, в которую будут временно помещаться данные для пересылки на сервер аудита:
    
     mkdir /var/spool/audit/
    
- Активировать плагин audisp-remote, указав значение yes в строке active файла конфигурации /etc/audisp/plugins.d/au-remote.conf

Завершаем настройку клиент-серверного журналирования аудита перезагрузкой демона auditd на сервере и на клиентах.

Теперь, пользуясь опцией -n или —node утилит aureport и ausearch на сервере аудита, с указанием имени узла, можно отображать события, которые относятся только к конкретному узлу.

Листинг файла /etc/audit/auditd.conf на сервере аудита:

> #
> # This file controls the configuration of the audit daemon
> #
> log_file = /var/log/audit/audit.log
> log_format = RAW
> log_group = root
> priority_boost = 4
> flush = INCREMENTAL
> freq = 20
> num_logs = 5
> disp_qos = lossy
> dispatcher = /sbin/audispd
> name_format = USER
> name = yar4e
> max_log_file = 100
> max_log_file_action = KEEP_LOGS
> space_left = 75
> space_left_action = SYSLOG
> action_mail_acct = root
> admin_space_left = 50
> admin_space_left_action = SUSPEND
> disk_full_action = SUSPEND
> disk_error_action = SUSPEND
> tcp_listen_port = 13000
> tcp_listen_queue = 10
> tcp_max_per_addr = 1
> ##tcp_client_ports = 1313-13130
> tcp_client_max_idle = 0
> enable_krb5 = no
> krb5_principal = auditd
> ##krb5_key_file = /etc/audit/audit.key


Листинг файла /etc/audisp/audisp-remote.conf с клиента:

> #
> # This file controls the configuration of the audit remote
> # logging subsystem, audisp-remote.
> #
> 
> remote_server = 192.168.200.254
> port = 13000
> ##local_port =
> transport = tcp
> queue_file = /var/spool/audit/remote.log
> mode = forward
> queue_depth = 2048
> format = managed
> network_retry_time = 1
> max_tries_per_record = 3
> max_time_per_record = 5
> heartbeat_timeout = 0
> 
> network_failure_action = syslog
> disk_low_action = ignore
> disk_full_action = ignore
> disk_error_action = syslog
> remote_ending_action = suspend
> generic_error_action = syslog
> generic_warning_action = syslog
> overflow_action = syslog
> 
> ##enable_krb5 = no
> ##krb5_principal =
> ##krb5_client_name = auditd
> ##krb5_key_file = /etc/audisp/audisp-remote.key