### Шпаргалка по journalctl в Linux

[источник](https://losst.pro/shpargalka-po-journalctl-v-linux)
[источник](https://habr.com/ru/companies/ruvds/articles/533918/)
Журналы - это один из самых важных источников информации при возникновении любых ошибок в операционной системе Linux. Я это уже много раз говорил ранее и вот сказал ещё раз. Раньше в Linux для сохранения журналов сервисов использовался отдельный демон под названием syslogd. Но с приходом системы инициализации systemd большинство функций касающихся управления сервисами перешли под её управление. В том числе и управление логами.

Теперь для просмотра логов определенного сервиса или загрузки системы необходимо использовать утилиту journalctl. В этой статье мы разберем примеры использования journalctl, а также основные возможности этой команды и её опции. По сравнению с обычными файлами журналов, у journalctl есть несколько преимуществ. Все логи находятся в одном месте, они индексируются и структурируются, поэтому к ним можно получить доступ в нескольких удобных форматах.

Содержание статьи

Синтаксис и опции journalctl
Горячие клавиши journalctl
Шпаргалка по journalctl
1. Просмотр логов сервисов
2. Просмотр логов в режиме tail
3. Просмотр логов загрузки
4. Фильтрация по дате
5. Журнал ядра
6. Настройка формата вывода
7. Очистка логов

## Синтаксис и опции journalctl

Синтаксис команды очень простой. Достаточно выполнить команду без опций или передав ей нужные опции. Если утилита не выводит ничего, выполните её от имени суперпользователя:

**journalctl опции**

А теперь давайте разберем основные опции journalctl:

- **--full, -l** - отображать все доступные поля;
- **--all, -a** - отображать все поля в выводе full, даже если они содержат непечатаемые символы или слишком длинные;
- **--pager-end, -e** - отобразить только последние сообщения из журнала;
- **--lines, -n** - количество строк, которые нужно отображать на одном экране, по умолчанию 10;
- **--no-tail** - отображать все строки доступные строки;
- **--reverse, -r** - отображать новые события в начале списка;
- **--output, -o** - настраивает формат вывода лога;
- **--output-fields** - поля, которые нужно выводить;
- **--catalog, -x** - добавить к информации об ошибках пояснения, ссылки на документацию или форумы там, где это возможно;
- **--quiet, -q** - не показывать все информационные сообщения;
- **--merge, -m** - показывать сообщения из всех доступных журналов;
- **--boot, -b** - показать сообщения с момента определенной загрузки системы. По умолчанию используется последняя загрузка;
- **--list-boots** - показать список сохраненных загрузок системы;
- **--dmesg, -k** - показывает сообщения только от ядра. Аналог вызова команды dmesg;
- **--identifier, -t** - показать сообщения с выбранным идентификатором;
- **--unit, -u** - показать сообщения от выбранного сервиса;
- **--user-unit** - фильтровать сообщения от выбранной сессии;
- **--priority, -p** - фильтровать сообщения по их приоритету. Есть восемь уровней приоритета, от 0 до 7;
- **--grep, -g** - фильтрация по тексту сообщения;
- **--cursor, -c** - начать просмотр сообщений с указанного места;
- **--since, -S, --until, -U** - фильтрация по дате и времени;
- **--field, -F** - вывести все данные из выбранного поля;
- **--fields, -N** - вывести все доступные поля;
- **--system** - выводить только системные сообщения;
- **--user** - выводить только сообщения пользователя;
- **--machine, -M** - выводить сообщения от определенного контейнера;
- **--header** - выводить заголовки полей при выводе журнала;
- **--disk-usage** - вывести общий размер лог файлов на диске;
- **--list-catalog** - вывести все доступные подсказки для ошибок;
- **--sync** - синхронизировать все не сохраненные журналы с файловой системой;
- **--flush** - перенести все данные из каталога /run/log/journal в /var/log/journal;
- **--rotate** - запустить ротацию логов;
- **--no-pager** - выводить информацию из журнала без возможности листать страницы;
- **-f** - выводить новые сообщения в реальном времени, как в команде tail;
- **--vacuum-time** - очистить логи, давностью больше указанного периода;
- **--vacuum-size** - очистить логи, чтобы размер хранилища соответствовал указанному.

## Горячие клавиши journalctl

По умолчанию информация лога выводится в формате, в котором её можно листать. Давайте разберем горячие клавиши, которые вы можете для этого использовать:

- **Стрелка вниз, Enter, e** или **j** - переместиться вниз на одну строку;
- **Стрелка вверх, y** или **k** - переместиться на одну строку вверх;
- **Пробел** - переместиться на одну страницу вниз;
- **b** - переместиться на одну страницу вверх;
- **Стрелка вправо, стрелка влево** - горизонтальна прокрутка;
- **g** - перейти на первую строку;
- **G** - перейти на последнюю строку;
- **p** - перейти на позицию нужного процента сообщений. Например, 50p перенесет курсор на середину вывода;
- **/** - поиск по журналу;
- **n** - найти следующее вхождение;
- **N** - предыдущее вхождение;
- **q** - выйти.

Теперь вы знаете основные опции команды и клавиши, с помощью которых можно ею управлять. Дальше небольшая шпаргалка journalctl.

## Шпаргалка по journalctl

Вывод journalctl представляет из себя цельный список всех сохраненных сообщений. Если вы запустите команду journalctl без параметров, то получите самые первые сообщения, которые были сохранены. В моем случае это данные за 13 января:

`sudo journalctl`

Чтобы найти именно то, что вам нужно, необходимо научится перемещаться по этому списку. Формат вывода лога довольно простой:

**янв 13 20:55:55 sergiy-pc kernel: Linux version 4.15.0-43-generic**

- **янв 13 20:55:55** - дата и время события;
- **sergiy-pc** - хост, на котором произошло событие;
- **kernel** - источник события, обычно это программа или сервис. В данном случае ядро;
- **Linux version 4.15.0-43-generic** - само сообщение.

Давайте перейдем к примерам фильтрации и перемещения.

### 1. Просмотр логов сервисов

Самый частый случай использования journalctl - это когда вы пытаетесь запустить какой-либо сервис с помощью systemd, он не запускается и systemd выдает вам такое сообщение подобного содержания: Failed to start service use journalctl -xe for details. Система сама предлагает вам какую команду надо выполнить:

`sudo journalctl -xe`

Как вы помните из опций, эта команда отображает последние сообщения в журнале и добавляет к ним дополнительную информацию, если она есть. Учитывая, что последнее, что мы делали - был наш сервис, то здесь будут сообщения от него и вы быстро сможете понять почему он не запускается.

Чтобы отфильтровать сообщения только от определенного сервиса можно использовать опцию -u. Например:

`sudo journalctl -eu apache2.service`

### 2. Просмотр логов в режиме tail

С помощью опции -f можно указать утилите, что необходимо выводить новые сообщения в реальном времени:

`sudo journalctl -f`

В этом режиме less не поддерживается, поэтому для выхода нажмите сочетание клавиш **Ctrl+C**.

### 3. Просмотр логов загрузки

В логе journalctl содержатся все логи, в том числе и логи загрузки. Для того чтобы открыть лог последней загрузки используйте опцию -b:

`sudo journalctl -b`

Посмотреть список всех сохраненных загрузок можно командой:

`sudo journalctl --list-boots`
Теперь, чтобы посмотреть сообщения для нужной загрузки используйте её идентификатор:

`sudo journalctl -b 37d5c906c9c6404682f029b2c34ec9dc`

Первый номер в ответе journalctl -list-boots показывает номер журнала, который можно использовать для просмотра журнала определенной сессии. Второй номер boot ID так же можно использовать для просмотра отдельного журнала.  
  
Следующие две даты, промежуток времени в течении которого в него записывались логи, это удобно если вы хотите найти логи за определенный период.  
  
Например, чтобы просмотреть журнал начиная с текущего старта системы, можно использовать команду:  

`# journalctl -b 0`

А для того, чтобы просмотреть журнал предыдущей загрузки:  

`# journalctl -b -1`

### 4. Фильтрация по дате

С помощью опции **--since** вы можете указать дату и время, начиная с которой нужно отображать логи:

`sudo journalctl --since "2019-01-20 15:10:10"`

Опция **--until** помогает указать по какую дату вы хотите получить информацию:

`sudo journalctl -e --until "2019-01-20 15:05:50"`

Или сразу скомбинируем две эти опции чтобы получить логи за нужный период:

`sudo journalctl --since "2019-01-20 15:10:10" --until "2019-01-20 15:05:50"`

Кроме даты в формате YYYY-MM-DD в этих опциях можно использовать такие слова, как yesterday, today, и tomorrow. Также допустимы конструкции **1 day ago** (один день назад) или **3 hours ago** (три часа назад). Ещё можно использовать знаки + и -. Например **-1h30min** будет означать полтора часа назад.

Со вчерашнего дня:  

```
# journalctl --since yesterday
```
  
С 9 утра и до момента, час назад:  

```
# journalctl --since 09:00 --until "1 hour ago"
```

### 5. Журнал ядра

Если вы хотите посмотреть только сообщения ядра используйте опцию -k:

`sudo journalctl -ek`

### 6. Настройка формата вывода

По умолчанию journalctl выводит информацию с помощью утилиты less, в которой вы можете её удобно листать и просматривать. Но формат вывода можно изменить:

- **short** - используется по умолчанию;
- **verbose** - также, как и short, только выводится намного больше информации;
- **json** - вывод в формате json, одна строка лога в одной строке вывода;
- **json-pretty** - форматированный вывод json для более удобного восприятия;
- **cat** - отображать только сообщения, без метаданных.

Чтобы указать нужный формат используйте опцию -o. Например:

`sudo journalctl -o json-pretty`

Или:

`sudo journalctl -eo json-pretty`

### 7. Очистка логов

Сначала нужно посмотреть сколько ваши логи занимают на диске. Для этого используйте такую команду:

`sudo journalctl --disk-usage`

Чтобы уменьшить размер лога можно использовать опцию --vacuum-size. Например, если вы хотите, чтобы ваши файлы журналов занимали на диске не более 2 Гб, выполните команду:

`sudo journalctl --vacuum-size=2G`

Теперь старые логи будут удалены, пока общий объем хранилища не будет составлять 2 гигабайта. Также можно удалять логи по времени. Для этого используется опция --vacuum-time. Например, оставим только логи за последний год:

`journalctl --vacuum-time=1years`

Удалить журналы, оставив только последние 100 Мб:  
`# journalctl --vacuum-size=100M`  

Удалить журналы, оставив журналы только за последние 7 дней:  
`# journalctl --vacuum-time=7d`

### 8.Фильтрация событий по важности

  
Система записывает события с различными уровнями важности, какие-то события могут быть предупреждением, которое можно проигнорировать, какие-то могут быть критическими ошибками. Если мы хотим просмотреть только ошибки, игнорируя другие сообщения, введем команду с указанием кода важности:  

` journalctl -p 0`  
  
Для уровней важности, приняты следующие обозначения:  

- 0: emergency (неработоспособность системы)
- 1: alerts (предупреждения, требующие немедленного вмешательства)
- 2: critical (критическое состояние)
- 3: errors (ошибки)
- 4: warning (предупреждения)
- 5: notice (уведомления)
- 6: info (информационные сообщения)
- 7: debug (отладочные сообщения)
 
Когда вы указываете код важности, journalctl выведет все сообщения с этим кодом и выше. Например если мы укажем опцию -p 2, journalctl покажет все сообщения с уровнями 2, 1 и 0.

### 9.Просмотр журнала логов для определенного сервиса systemd или приложения
  
Вы можете отфильтровать логи по определенному сервису systemd. Например, что бы просмотреть логи от NetworkManager, можно использовать следующую команду:

```
# journalctl -u NetworkManager.service
```

  
Если нужно найти название сервиса, используйте команду:  
  

```
# systemctl list-units --type=service
```

  
Так же можно просмотреть лог приложения, указав его исполняемый файл, например чтобы просмотреть все сообщения от nginx за сегодня, мы можем использовать команду:  
  

```
# journalctl /usr/sbin/nginx --since today
```

  
Или указав конкретный PID:  
  

```
# journalctl _PID=1
```

To see all the logs from vsftpd and firewalld you can run this command:

`journalctl -u vsftpd.service -u firewalld.service   `  
You can also specify a time in absolute, relative or any combination.

`journalctl -u vsftpd.service -u firewalld.service --since "2 days ago"`

**Displaying Logs by User or Group**

Other things you can do is find logs generated by a specific user (UID) or group (GUID).

For example, let's say I wanted to see all logs from the user "savona".  First I would find their UID like so:


```
[root@bighat ~]# id savona   
uid=1000(savona) gid=1000(savona) groups=1000(savona)
```
Now that I know their UID is 1000, I can use the _UID filter in journalctl like so:

`journalctl _UID=1000   `  
And of course I can mix this with a time window:

`journalctl _UID=1000 --since "2 days ago"`