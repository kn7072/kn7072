https://www.man7.org/linux/man-pages/man1/strace.1.html

$ strace опции команда аргументы

В самом простом варианте strace запускает переданную команду с её аргументами и выводит в стандартный поток ошибок все системные вызовы команды. Давайте разберём опции утилиты, с помощью которых можно управлять её поведением:

    -i - выводить указатель на инструкцию во время выполнения системного вызова;
    -k - выводить стек вызовов для отслеживаемого процесса после каждого системного вызова;
    -o - выводить всю информацию о системных вызовах не в стандартный поток ошибок, а в файл;
    -q - не выводить сообщения о подключении о отключении от процесса;
    -qq - не выводить сообщения о завершении работы процесса;
    -r - выводить временную метку для каждого системного вызова;
    -s - указать максимальный размер выводимой строки, по умолчанию 32;
    -t - выводить время суток для каждого вызова;
    -tt - добавить микросекунды;
    -ttt - добавить микросекунды и количество секунд после начала эпохи Unix;
    -T - выводить длительность выполнения системного вызова;
    -x - выводить все не ASCI-строки в шестнадцатеричном виде;
    -xx - выводить все строки в шестнадцатеричном виде;
    -y - выводить пути для файловых дескрипторов;
    -yy - выводить информацию о протоколе для файловых дескрипторов;
    -c - подсчитывать количество ошибок, вызовов и время выполнения для каждого системного вызова;
    -O - добавить определённое количество микросекунд к счетчику времени для каждого вызова;
    -S - сортировать информацию выводимую при опции -c. Доступны поля time, calls, name и nothing. По умолчанию используется time;
    -w - суммировать время между началом и завершением системного вызова;
    -e - позволяет отфильтровать только нужные системные вызовы или события;
    -P - отслеживать только системные вызовы, которые касаются указанного пути;
    -v - позволяет выводить дополнительную информацию, такую как версии окружения, статистику и так далее;
    -b - если указанный системный вызов обнаружен, трассировка прекращается;
    -f - отслеживать также дочерние процессы, если они будут созданы;
    -ff - если задана опция -o, то для каждого дочернего процесса будет создан отдельный файл с именем имя_файла.pid.
    -I - позволяет блокировать реакцию на нажатия Ctrl+C и Ctrl+Z;
    -E - добавляет переменную окружения для запускаемой программы;
    -p - указывает pid процесса, к которому следует подключиться;
    -u - запустить программу, от имени указанного пользователя.

Вы знаете основные опции strace, но чтобы полноценно ею пользоваться, нужно ещё разобраться с системными вызовами, которые используются чаще всего. Мы не будем рассматривать все, а только основные. Многие из них вы уже и так знаете, потому что они называются так же, как и команды в терминале:

    fork - создание нового дочернего процесса;
    read - попытка читать из файлового дескриптора;
    write - попытка записи в файловый дескриптор;
    open - открыть файл для чтения или записи;
    close - закрыть файл после чтения или записи;
    chdir - изменить текущую директорию;
    execve - выполнить исполняемый файл;
    stat - получить информацию о файле;
    mknod - создать специальный файл, например, файл устройства или сокет;

########################################################################################
Примеры использования Strace
1. Запуск программы
strace uname

Синтаксис вывода такой:
имя_системного_вызова (параметр1, параметр2) = результат сообщение

2. Подключение к запущенной программе
sudo strace -p 31796

3. Фильтрация системных вызовов
С помощью опции -e можно применять различные фильтры для более удобного поиска проблемы. Мы можем отобразить только вызовы stat, передав в опцию -e такой параметр trace=stat:

sudo strace -e trace=stat nautilus

Кроме непосредственно системных вызовов, в качестве параметра для trace можно передавать и такие значения:

    file - все системные вызовы, которые касаются файлов;
    process - управление процессами;
    network - сетевые системные вызовы;
    signal - системные вызовы, что касаются сигналов;
    ipc - системные вызовы IPC;
    desc - управление дескрипторами файлов;
    memory - работа с памятью программы.


4. Возвращение ошибки
Можно попросить strace вернуть программе ошибку по нужному системному вызову -e, но с параметром fault. Синтаксис конструкции такой:

fault=имя_вызова:error=тип_ошибки:when=количество

С именем вызова всё понятно, тип ошибки, номер ошибки, которую надо вернуть. А с количеством всё немного сложнее. Есть три варианта:

    цифра - вернуть ошибку только после указанного количества запросов;
    цифра+ - вернуть ошибку после указанного количества запросов и для всех последующих;
    цифра+шаг - вернуть ошибку для указанного количества и для последующих с указанным шагом.

Например, сообщим uname, что системного вызова uname не существует:

sudo strace -e fault=uname uname


5. Фильтрация по пути
Если вас интересует не определённый вызов, а все операции с нужным файлом, то можно выполнить фильтрацию по нему с помощью опции -P. Например, меня интересует, действительно ли утилита lscpu обращается к файлу /proc/cpuinfo, чтобы узнать информацию о процессоре:

strace -P /proc/cpuinfo lscpu

6. Статистика системных вызовов
С помощью опции -с вы можете собрать статистику для системных вызовов, которые использует программа. Например, сделаем это для nautilus:

sudo strace -c nautilus

Во время работы утилита ничего выводить не будет. Результат будет рассчитан и выведен, когда вы завершите отладку. В выводе будут такие колонки:

    time - процент времени от общего времени выполнения системных вызовов;
    seconds - общее количество секунд, затраченное на выполнение системных вызовов этого типа;
    calls - количество обращений к вызову;
    errors - количество ошибок;
    syscall - имя системного вызова.

Если вы хотите получать эту информацию в режиме реального времени, используйте опцию -C.

7. Отслеживание времени выполнения
Чтобы отображать время выполнения каждого системного вызова, используйте опцию -t:

strace -t unameЧтобы добавить время выполнения вызова, добавьте -T:
strace -ttt -T uname

ДОПОЛНИТЕЛЬНЫЕ ПРИМЕРЫ
tail -f | sudo  strace -i -e trace=file -p 11248
################################################################################
# https://habr.com/ru/company/badoo/blog/493856/
Предположим, что нас интересуют только вызовы write. Ключ -e позволяет указывать выражения, по которым будут фильтроваться системные вызовы. 
strace -e trace=write -o write-simple.log ./write-simple


Отслеживать дерево процессов целиком помогает флаг -f, с которым strace отслеживает системные вызовы в процессах-потомках. К каждой строке вывода при этом добавляется pid процесса, делающего системный вывод:

strace -f -e trace=write -o fork-write.log ./fork-write

В этом контексте может пригодиться фильтрация по группам системных вызовов:
strace -f -e trace=%process -ofork-write.log ./fork-write

С флагом -y утилита показывает путь к файлу, которому соответствует дескриптор:
strace -y -e trace=write -o write-tmp-file.log ./write-tmp-file

По умолчанию strace выводит много лишней информации. Флаг -P с аргументом заставляет strace выводить только обращения к указанному файлу:
strace -y -P /tmp/test_file.log -o write-file.log ./write-file /tmp/test_file.log

Мастер-класс: инъекция ошибок
А теперь используем выражение inject, чтобы вставить ошибку EBADF во все вызовы write:
strace -e trace=write -e inject=write:error=EBADF -o write-twice.log ./write-twice

Интересно, что ошибки возвращают все вызовы write, включая вызов, скрытый за perror. Имеет смысл возвращать ошибку только для первого из вызовов:
strace -e trace=write -e inject=write:error=EBADF:when=1 -o write-twice.log ./write-twice

Или второго:
strace -e trace=write -e inject=write:error=EBADF:when=2 -o write-twice.log ./write-twice

Тип ошибки указывать не обязательно:
strace -e trace=write -e fault=write:when=1 -o write-twice.log ./write-twice

В сочетании с другими флагами можно «ломать» обращения к конкретному файлу. Пример:
strace -y -P/tmp/test_file.log -e inject=file:error=ENOENT -o write-file.log ./write-file /tmp/test_file.log

какие файлы открывает flake8
strace -e trace=openat -o flake8.log flake8

Помимо инъекций ошибок, можно вводить задержки при выполнении вызовов или получении сигналов.

################################################################################
# https://xakep.ru/2011/01/13/54477/
Например, чтобы отследить все вызовы open и access (а на них следует обращать внимание в первую очередь при проблемах с запуском приложения):

$ strace -e trace=open,access -o strace.log uname

Вместо перечисления всех нужных вызовов можно использовать классы, состоящие только из специализированных вызовов: file, process, network, signal или ipc. Также можно писать в лог все вызовы, кроме одного.
Например, чтобы исключить вызов mmap:

$ strace -e trace=\!mmap -o strace.log uname
К сожалению, исключить из вывода сразу несколько вызовов не получится. 

Некоторые приложения в процессе работы любят наплодить большое количество дочерних процессов. По умолчанию strace игнорирует дочерние процессы, но это поведение можно изменить с помощью опции '-f'.

Если вывод strace пишется в лог, то удобно использовать опцию '-ff', которая заставляет strace писать трассировку каждого процесса в отдельный лог вида filename.PID.

Проблемы с сетью
strace -f -e trace=network firefox xakep.ru
Вызов connect из листинга показывает, что Firefox сначала обращается к сервису NSCD (кэширующий демон) для разрешения имен, а только потом, если NSCD ничего не выдаст — к DNS. На ноутбуке NSCD только мешается, поэтому я его смело удалил, после чего огнелис нашел правильный айпишник.

Проблемы с псевдоустройствами
Бывает, что какое-то приложение просто виснет, не выдавая никаких ошибок и завершаясь только по kill. Или работает, но тормозит на, казалось бы, простейшей операции.
strace -f -o /tmp/samsdaemon /etc/init.d/samsd start
На последнем вызове система задумывается больше, чем на минуту. Значит, проблема в /dev/random. SAMS применяет его для создания хешей паролей пользователей. Самое простое решение — использовать /dev/urandom, который гораздо быстрее, чем /dev/random.

Сажаем nginx в песочницу
Безопасности много не бывает, поэтому никакая дополнительная ступень защиты лишней не будет. Достаточно популярный и простой в реализации механизм минимизации урона от взлома — запуск приложения в chroot. Процесс переноса приложения в песочницу не сложен, если воспользоваться strace и еще одной полезной утилитой — ldd (показывает список совместно используемых библиотек ELFфайла). Покажу на примере, как запускать в chroot популярный на просторах рунета веб-сервер nginx.

Предположим, что nginx (последней на момент написания статьи версии 0.8.40) уже собран с параметрами по умолчанию и лежит в /usr/local. Список библиотек, которые нужны ему для работы:

# ldd /usr/local/nginx/sbin/nginx
linux-gate.so.1 => (0xb7789000)
libcrypt.so.1 => /lib/i686/cmov/libcrypt.so.1
(0xb7751000)
libpcre.so.3 => /usr/lib/libpcre.so.3 (0xb7728000)
libssl.so.0.9.8 => /usr/lib/i686/cmov/libssl.so.0.9.8 (0xb75d4000)
libcrypto.so.0.9.8 => /usr/lib/i686/cmov/libcrypto.so.0.9.8 (0xb7cde000)
libz.so.1 => /usr/lib/libz.so.1 (0xb75bf000)
libc.so.6 => /lib/i686/cmov/libc.so.6 (0xb7464000)
libdl.so.2 => /lib/i686/cmov/libdl.so.2 (0xb7460000)
/lib/ld-linux.so.2 (0xb778a000)

Переносим эти библиотеки в заранее созданное chroot-окружение (например, /chroot/nginx). Дальше, чтобы удостовериться в том, что у нас есть все необходимые библиотеки, нужно с помощью ldd посмотреть также зависимости скопированных библиотек. Кроме библиотек nginx'у нужны еще некоторые конфиги и логи. Получим список необходимых файлов:

# strace -e trace=open /usr/local/nginx/sbin/nginx
open("/etc/ld.so.cache", O_RDONLY) = 3
open("/lib/i686/cmov/libcrypt.so.1", O_RDONLY) = 3
open("/usr/lib/libpcre.so.3", O_RDONLY) = 3
open("/usr/lib/i686/cmov/libssl.so.0.9.8", O_RDONLY)
= 3
open("/usr/lib/i686/cmov/libcrypto.so.0.9.8",
O_RDONLY) = 3
…
open("/etc/passwd", O_RDONLY|O_CLOEXEC) = 4
open("/etc/group", O_RDONLY|O_CLOEXEC) = 4
open("/usr/local/nginx/logs/access.log", O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE, 0644) = 4
open("/usr/local/nginx/logs/error.log", O_WRONLY|O_CREAT|O_APPEND|O_LARGEFILE, 0644) = 5

Скопируем недостающие файлы, удаляя при этом из конфигов ненужную информацию (например, лишних пользователей из /etc/ passwd).

Создадим в chroot-окружении /dev/null, необходимый для нормального функционирования nginx'а:

# mknod /chroot/nginx/dev/null c 1 3

Вот и все. Теперь запускать nginx в chroot можно следующим образом:

# chroot /chroot/nginx/ /usr/local/nginx/sbin/nginx


