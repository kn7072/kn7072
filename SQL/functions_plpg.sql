SELECT t.* FROM employees t;

--https://postgrespro.ru/docs/postgrespro/14/sql-selectinto
SELECT INTO создаёт новую таблицу и заполняет её данными, полученными из запроса. 
SELECT * INTO films_recent FROM films WHERE date_prod >= '2002-01-01';

--https://postgrespro.ru/docs/postgrespro/14/sql-createtableas
CREATE TABLE AS создаёт таблицу и наполняет её данными, полученными в результате выполнения SELECT. Столбцы этой таблицы получают имена и типы данных в соответствии со столбцами результата SELECT (хотя имена столбцов можно переопределить, добавив явно список новых имён столбцов).

-- Иногда бывает полезно вычислить значение выражения или запроса SELECT, но отказаться от результата, например, при вызове функции, у которой есть побочные эффекты, но нет полезного результата. Для этого в PL/pgSQL, используется оператор PERFORM:
PERFORM запрос;
--Эта команда выполняет запрос и отбрасывает результат. Запросы пишутся таким же образом, как и в команде SQL SELECT, но ключевое слово SELECT заменяется на PERFORM.
--пример
PERFORM create_mv('cs_session_page_requests_mv', my_query);

--41.5.3. Выполнение команды, возвращающей одну строку
--Результат SQL-команды, возвращающей одну строку (возможно из нескольких столбцов), может быть присвоен переменной типа record, переменной строкового типа или списку скалярных переменных. Для этого нужно к основной команде SQL добавить предложение INTO. Так, например:

SELECT выражения_select INTO [STRICT] цель FROM ...;
INSERT ... RETURNING выражения INTO [STRICT] цель;
UPDATE ... RETURNING выражения INTO [STRICT] цель;
DELETE ... RETURNING выражения INTO [STRICT] цель;

--где цель может быть переменной типа record, строковой переменной или разделённым запятыми списком скалярных переменных, полей записи/строки.

41.5.4. Выполнение динамически формируемых команд
Часто требуется динамически формировать команды внутри функций на PL/pgSQL, то есть такие команды, 
в которых при каждом выполнении могут использоваться разные таблицы или типы данных. Обычно PL/pgSQL кеширует планы выполнения 
(как описано в Подразделе 41.11.2), но в случае с динамическими командами это не будет работать. Для исполнения динамических команд предусмотрен оператор EXECUTE:

EXECUTE строка-команды [ INTO [STRICT] цель ] [ USING выражение [, ... ] ];

где строка-команды это выражение, формирующее строку (типа text) с текстом команды, которую нужно выполнить. 
Необязательная цель — это переменная-запись, переменная-кортеж или разделённый запятыми список простых переменных и полей записи/кортежа, 
куда будут помещены результаты команды. Необязательные выражения в USING формируют значения, которые будут вставлены в команду.

Обратите внимание, что символы параметров можно использовать только вместо значений данных. 
Если же требуется динамически формировать имена таблиц или столбцов, их необходимо вставлять в виде текста. 
Например, если в предыдущем запросе необходимо динамически задавать имя таблицы, можно сделать следующее:

EXECUTE 'SELECT count(*) FROM '
    || quote_ident(tabname)
    || ' WHERE inserted_by = $1 AND inserted <= $2'
   INTO c
   USING checked_user, checked_date;

Более аккуратным решением будет использование указания %I с функцией format(), позволяющее вставить имя таблицы или столбца, которое будет автоматически заключено в кавычки:

EXECUTE format('SELECT count(*) FROM %I '
   'WHERE inserted_by = $1 AND inserted <= $2', tabname)
   INTO c
   USING checked_user, checked_date;




