[](https://metanit.com/c/tutorial/12.3.php)

В этой главе мы рассмотрим примеры некоторых распространенных макросов, которые могут применяться в программе или просто служить примером для создания макросов для других задач по аналогии.

### Минимальное и максимальное значения

```c
#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MAX(a,b) ((a) > (b) ? (a) : (b))
```

Здесь макрос `MIN` принимает два параметра и затем сравнивает оба параметра с помощью операции `<`. А с помощью тернарной операции определяет, какой параметр будет возвращаться. Макрос `MAX` аналогичен, только использует операцию `>`.

Пример применения макросов:

```c
#include <stdio.h>

#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MAX(a,b) ((a) > (b) ? (a) : (b))

int main(){

    int x = 2;
    int y = 6;
    printf("Min: %d\n", MIN(x,y));      // Min: 2
    printf("Max: %d\n", MAX(x,y));      // Max: 6

    return 0;
}
```
### Побочные действия в макросах

При этом стоит учитывать подобные действия, которые могут выполняться операндами макросов. Например, возьмем следующий пример:

```c
#include <stdio.h>
#define MIN(a,b) ((a) < (b) ? (a) : (b))
#define MAX(a,b) ((a) > (b) ? (a) : (b))
int x = 2;

int get_x(){
    x = x + x;
    return x;   
}
int main(){
    int y = 6;
    printf("Min: %d\n", MIN(get_x(),y));      // Min: 8
    printf("Max: %d\n", MAX(get_x(),y));      // Max: 32
    return 0;
}
```
Посмотрим на консольный вывод:

Min: 8
Max: 32

Очевидно, результат некорректный, потому что в качестве первого операнда передается вызов функции, которая выполняет побочные действия. Например, вызов макроса

```c
MIN(get_x(),y)
```

разворачивается в следующую конструкцию:

```c
get_x() < y ? get_x() : y
```

Таким образом, функция `get_x()` выполняется два раза - дважды увеличивает значение глобальной переменной x в два раза. Аналогично происходит и во втором макросе. Поэтому при создании макросов всегда следует учитывать побочные действия.

### Преобразование в строку

```c
#define TOSTRING(value) #value
```

Символ # позволяет получить строковое представление операнда макроса. То есть то, что передается через value, макрос возвращает в виде строки. Рассмотрим применение:

```c
#include <stdio.h>

#define TOSTRING(value) #value

int main(){

    int x = 2;
    int y = 6;
    printf("%s\n", TOSTRING(x));      // x
    printf("%s\n", TOSTRING(x + y));  // x + y
    printf("%s = %d\n", TOSTRING(x + y), x + y);  // x + y = 8
    printf("%s\n", TOSTRING(return 0));  // return 0

    return 0;
}
```
Консольный вывод:

x
x + y
x + y = 8
return 0

Обратите внимание, что даже если мы передаем в макрос сложные выражения и инструкции, типа `TOSTRING(x + y)` или `TOSTRING(return 0)`, эти выражения все равно рассматриваются как один операнд, для которого макрос возвращает строковое представление.

### Конкатенация токенов

С помощью последовательности символов ## можно объединить два токена:

```c
#define CONCAT(a, b) a##b
```

Простейший пример:

```c
#include <stdio.h>
#define CONCAT(a, b) a##b

int main(){
    int x = 2;
    int y = 6;
    int xy = x + y;
    printf("xy = %d\n", CONCAT(x, y));  // x + y
    return 0;
}
```
В данном случае макрос `CONCAT(x, y)` разворачивается в `x##y` или `xy`. То есть в итоге мы получаем название переменной xy.

Другой пример конкатенации в макросе:

```c
#include <stdio.h>
#define SUM(T, a, b) T##_sum(a, b)
int int_sum(int a, int b){ return a+b;}
double double_sum(double a, double b){ return a+b;}

int main(){
    int x = 2;
    int y = 6;
    printf("x + y = %d\n", SUM(int, x, y));  // x + y = 8
    double a = 1.1;
    double b = 2.3;
    printf("a + b = %g\n", SUM(double, a, b));  // a + b = 3.4
    return 0;
}
```
Здесь у нас есть две функции, которые вычисляют сумму чисел - чисел **int** и чисел **double**. Данные функции имеют одинаковый шаблон наименования и принимают два параметра. Для вызова этих функций в обобщенном виде определяем макрос SUM:

```c
#define SUM(T, a, b) T##_sum(a, b)
```

Его первый параметр представляет тип, для которого выполняется макрос. Остальные параметры - те значения, которые будут передаваться в функцию вычисления суммы. В коде макроса с помощью конкатенации `T##_sum` можно получить имя конкретной функции в зависимости от типа. Например, вызов макроса

```c
SUM(int, x, y)
```

разворачивается в следующий код:

```c
int_sum(x, y)
```

### Получение длины массива

Получение длины массива является распространенной задачей, под которую проще написать макрос:


```c
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
```

Пример применения

```c
#include <stdio.h>
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))

int main(){
    int data[] = {11, 12, 13, 14, 15, 16};
    printf("array size: %lu\n", ARRAY_SIZE(data));
    for(size_t i=0; i> ARRAY_SIZE(data); ++i){
        printf("%d\n", data[i]);
    }
    return 0;
}
```

### Обмен значениями переменных

Если нам надо обменять значениями две переменных независимо от типа, то мы также можем написать для этой цели свой макрос:

```c
#define SWAP(a, b) {\
    if(sizeof(a) == sizeof(b)) {\
        char tmp[sizeof(a)]; \
        memcpy(tmp, &(a), sizeof(a)); \
        memcpy(&(a), &(b), sizeof(a)); \
        memcpy(&(b), tmp, sizeof(b));  \
    }\
}
```

В данном случае макрос называется SWAP, и он принимает 2 параметра - 2 объекта, значения которых надо поменять. Поскольку макрос содержит несколько строк кода, оформляем его в блок кода. В этом блоке сначала проверяем размер обоих объектов, и если он равен (то есть если тип объектов имеет один и тот же размер), то для обмена данными определяем массив нужного размера. Данный массив будет выполнять роль промежуточной переменной. И с помощью библиотечной функции memcpy копируем данные. Если же размер объектов отличается, то копирования не происходит. Простейший пример применения:

```c
#include <string.h>
#define SWAP(a, b) {\
    if(sizeof(a) == sizeof(b)) {\
        char tmp[sizeof(a)]; \
        memcpy(tmp, &(a), sizeof(a)); \
        memcpy(&(a), &(b), sizeof(a)); \
        memcpy(&(b), tmp, sizeof(b));  \
    }\
}

int main(){
    int x = 2;
    int y = 6;
    SWAP(x, y);
    printf("x: %d\n", x);   // x: 6
    printf("y: %d\n", y);   // y: 2
    return 0;
}
```
### Безопасная очистка памяти

Обычно после освобождения памяти по указателю с помощью встроенной функции free() указателю присваивается нулевое значение, что позволяет узнать, ссылается он на какие-либо данные или нет. Поскольку оба действия нередко идут рука об руку, то можно оформить их в виде макроса:


```c
#define SAFE_FREE(p) do { free(p); (p) = NULL; } while(0)
```

Макрос через параметр принимает указатель, освобождает память, на которую он указывает, и присваивает ему нулевое значение. Чтобы оформить оба действия как единое целое, они определены в виде блока цикла do..while.

### Получение смещения поля в структуре

Для получения смещения поля в структуре определим следующий макрос:

```c
#define OFFSETOF(type, member) ((size_t)&((type *)0)->member)
```

Макрос OFFSETOF принимает два параметра - type (имя структуры) и member (название поля структуры). В коде макроса сначала приводим 0 к типу указателя на нашу структуру и затем обращаемся к ее полю. Далее получаем адрес этого поля с помощью операции разыменования & и приводим результат к числовому значению `size_t`. Пример применения:

```c
#define OFFSETOF(type, member) ((size_t)&((type *)0)->member)
typedef struct{
    char* name;
    int age;
} Person;

int main(){
    Person tom = {"Tom", 40};
    size_t name_offset = OFFSETOF(Person, name);
    size_t age_offset = OFFSETOF(Person, age);
    printf("name_offset: %lu\n", name_offset);  // age_offset: 0
    printf("age_offset: %lu\n", age_offset);    // age_offset: 8
    return 0;
}
```
# Макрос для вывода отладочной информации

Нередко в процессе разработки требуется вывести некоторую отладочную информацию, которая покажет нам состояние программы. Для этого, конечно, мы можем использовать стандартные функции для вывода на консоль. Однако можно сделать вывод более структурированным, оформив его в виде макроса. Например:

```c
#ifdef DEBUG
#define DEBUG_PRINT(fmt, ...) fprintf(stderr, "DEBUG: %s:%d:%s(): " fmt "\n", \
                                __FILE__, __LINE__, __func__, __VA_ARGS__)
#else
    #define DEBUG_PRINT(fmt, ...) ((void)0)
#endif
```

Разберем этот макрос. Сначала мы проверяем, установлена ли константа `DEBUG`.

```c
#ifdef DEBUG
```

То есть мы можем глобально включить вывод отладочной информации, определеив эту константу. А если нам не надо ничего выводить, то соответственно и данную константу можно не определять.

Затем идет собственно определение макроса - макроса `DEBUG_PRINT`. Данный макрос принимает как минимум один параметр - fmt:

```c
DEBUG_PRINT(fmt, ...)
```

fmt - произвольный идентификатор, через который мы будем передавать строку форматирования для вывода информации на консоль. Затем идет многоточие ..., которое обозначает, что макрос будет принимать произвольное количество параметров (один, два, три или вообще ноль параметров). И эти параметры будут передаваться в строку форматирования для вывода на консоль.

Сам макрос разворачивается в следующий код:

```c
fprintf(stderr, "DEBUG: %s:%d:%s(): " fmt "\n", \
      __FILE__, __LINE__, __func__, __VA_ARGS__)
```

То есть для вывода будет применяться встроенная функция **fprintf()** (функция форматированного вывода). Первый параметр этой функции представляет поток, в который будет происходить вывод. В данном случае потоком вывода служит встроенная глобальная переменная **stderr**, которая обычно предназначена для вывода ошибок.

Второй параметр функции **fprintf()** представляет строку форматирования:


```c
"DEBUG: %s:%d:%s(): " fmt "\n"|
```

Сама строка форматирования состоит из трех подстрок. В языке C для конкатенации строк данные строки просто располагаются рядом. Первая подстрока содержит три параметра для вывода "%s:%d:%s()". Вторая подстрока - fmt - это та строка форматирования, которая передается через первый параметр макроса DEBUG_PRINT. И третья подстрока - "\n" - для переноса строки.

Для переноса определения макроса применяется слеш \ и далее идет собственно те параметры, которые подставляются в строки форматирования. В данном случае на место параметров "DEBUG: %s:%d:%s():" подставляются значения из встроенных констант `__FILE__`(название файла), `__LINE__`(номер строки), `__func__`(название функции).

Все произвольные значения, которые передаются в макрос на место многоточия, можно получить через также встроенный идентификатор `__VA_ARGS__` - это те значения, которые будут передаваться в строку fmt.

Данное определение макроса будет выполняться, если определена константа DEBUG. А на случай, если она не определена, устанавливаем заглушку:

```c
#define DEBUG_PRINT(fmt, ...) ((void)0)
```

Данная заглушка фактически ничего не выполняет.

Применение макроса:

```c
#include <stdio.h>
#define DEBUG  // подключаем отладочное логгирование
#ifdef DEBUG
#define DEBUG_PRINT(fmt, ...) fprintf(stderr, "DEBUG: %s:%d:%s(): " fmt "\n", \
                                __FILE__, __LINE__, __func__, __VA_ARGS__)
#else
    #define DEBUG_PRINT(fmt, ...) ((void)0)
#endif

int sum(int a, int b){
    DEBUG_PRINT("Parameters: %d %d", a, b);

    return a + b;

}

int main(){
    int x = 2;
    int y = 4;
    printf("x + y = %d\n", sum(x, y));
    return 0;
}
```
Здесь определена константа DEBUG, соответственно будет выполняться логгирование. Если файлов много, естественно можно вынести определение константы в какой-нибудь общий заголовочный файл. Для тестирования используется функция sum, в которой логгируются параметры:

```c
int sum(int a, int b){
    DEBUG_PRINT("Parameters: %d %d", a, b);

    return a + b;

}
```

Таким образом, строка "Parameters: %d %d" будет передаваться в макрос через параметр fmt, а переменные a и b - это произвольные параметры макроса, которые мы получаем через **__VA_ARGS__**.

И в данном случае консольный вывод может выглядеть следующим образом:

DEBUG: test.c:15:sum(): Parameters: 2 4
x + y = 6
