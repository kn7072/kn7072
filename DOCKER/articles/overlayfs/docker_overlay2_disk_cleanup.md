[источник](https://fastfox.pro/blog/tutorials/docker-overlay2-disk-cleanup/?ysclid=mlp0tivw8v884558508)

- [ Docker overlay2: как освободить место (image prune, builder cache, volumes) без сюрпризов](#link_1)
- [ Что такое overlay2 и почему заканчивается диск](#link_2)
- [ Карта хранения Docker: что лежит в /var/lib/docker](#link_3)
- [ Диагностика: быстро понять, куда ушло место](#link_4)
- [ Образы и docker image prune: что удалится на самом деле](#link_5)
  - [ Ловушка: остановленные контейнеры удерживают образы](#link_6)
- [ Builder cache (BuildKit): почему сборки Dockerfile раздувают диск](#link_7)
  - [ Как уменьшить рост кэша сборки на будущее](#link_8)
- [ Docker volumes: где прячутся реальные данные](#link_9)
  - [ Типовой сценарий утечки томов в docker compose](#link_10)
- [ Комплексная уборка: docker system prune и почему с ним осторожно](#link_11)
- [ Почему место не освобождается сразу: частые причины](#link_12)
- [ Безопасный чек-лист очистки для продакшена](#link_13)
- [ Стратегия на будущее: держим overlay2 под контролем](#link_14)

## Docker overlay2: как освободить место (image prune, builder cache, volumes) без сюрпризов <a name="link_1"></a>

Почему Docker с overlay2 внезапно съедает диск: слои образов, остановленные контейнеры, BuildKit-кэш и тома. Команды для диагностики, безопасной очистки и чек-лист для продакшена, чтобы освободить место без сюрпризов.

Когда Docker «вдруг съедает» гигабайты на сервере, почти всегда виноват не один огромный файл, а накопление артефактов в `/var/lib/docker`: слои образов, кэш сборки, остановленные контейнеры, логи и забытые тома. На Linux по умолчанию чаще всего используется драйвер хранения **overlay2**: он быстрый, но при активной сборке и деплое способен разрастаться незаметно.

## Что такое overlay2 и почему заканчивается диск <a name="link_2"></a>

**overlay2** — это реализация overlay filesystem: каждый слой образа и каждый writable-слой контейнера хранится как отдельный каталог. Поверх «нижних» read-only слоёв образа накладывается writable слой контейнера. Если вы часто пересобираете образы, используете CI, откаты, несколько тегов, multi-stage сборки — слоёв и кэша становится много.

Важно: «раздутый overlay2» — не обязательно баг. Чаще это нормальная цена за скорость сборок и повторное использование слоёв. Проблема начинается, когда место заканчивается, а вы не понимаете, что можно чистить безопасно и что именно принесёт эффект.

Главная мысль: не лечите симптом «overlay2 большой» — сначала определите, что именно занимает место (images, containers, build cache, volumes или логи), и только потом выбирайте команду очистки.

## Карта хранения Docker: что лежит в /var/lib/docker <a name="link_3"></a>

Упрощённо на хосте это выглядит так:

- `/var/lib/docker/overlay2` — слои образов и writable-слои контейнеров (часто основной «пожиратель» места).
- `/var/lib/docker/containers` — логи контейнеров (часто растут из-за stdout/stderr).
- `/var/lib/docker/volumes` — данные томов (БД, uploads, кэши приложений).
- `/var/lib/docker/buildkit` — кэш BuildKit и артефакты сборок (если BuildKit включён).
- `/var/lib/docker/image` — метаданные образов.

Когда вы видите, что `overlay2` занимает десятки гигабайт, это обычно сумма:

- образов (особенно «висящих» или старых тегов),
- остановленных контейнеров с их writable слоями,
- builder cache, который хранит результаты промежуточных стадий сборки,
- томов, которые никто не использует (особенно после пересоздания compose-проектов).

Если вы выбираете сервер под проекты с контейнерами, учитывайте запас диска и IOPS: Docker легко превращает «маленький VPS» в систему, где место и скорость диска — главные ограничения. Для таких задач часто удобнее [VDS](https://fastfox.pro/vds/) с нормальным SSD и предсказуемыми ресурсами.

## Диагностика: быстро понять, куда ушло место <a name="link_4"></a>

Сначала — базовые метрики на уровне Docker:

```
docker system df
```

Для детального разбора (обычно это самое полезное):

```
docker system df -v
```

Дальше — взгляд со стороны ОС: так вы быстро поймёте, что именно раздулось (overlay2, volumes или логи):

```
sudo du -h -d 1 /var/lib/docker | sort -h
```

Если огромный вклад дают логи контейнеров:

```
sudo du -h -d 1 /var/lib/docker/containers | sort -h
```

Если подозрение на тома:

```
sudo du -h -d 1 /var/lib/docker/volumes | sort -h
```

> Сначала определяем «класс» мусора через `docker system df -v`, затем подтверждаем цифры через `du`. Чистка наугад почти всегда заканчивается либо недоочисткой, либо удалением нужного.

## Образы и docker image prune: что удалится на самом деле <a name="link_5"></a>

Команды с **image prune** чаще всего ищут в момент, когда «кончился диск», и именно здесь много ошибок из-за неверных ожиданий.

Практически полезно разделять образы на три группы:

- **используемые** — на них ссылаются существующие контейнеры (в том числе остановленные);
- **неиспользуемые, но тегированные** — контейнеров нет, но есть теги (например, `myapp:old`);
- **dangling** — «висячие» слои без тега, часто появляются после пересборок (`<none>:<none>`).

Базовая и относительно безопасная чистка dangling-образов:

```
docker image prune
```

Чтобы удалить _все_ образы, которые не используются ни одним контейнером (включая остановленные), используется флаг `-a`:

```
docker image prune -a
```

Это уже агрессивнее: если вы держите «запасной» образ с тегом, но контейнер на нём сейчас не существует, он будет удалён. Следующий деплой потянет образ заново (время, трафик, риск задержки релиза).

Часто лучший компромисс — чистить «неиспользуемое и старое» по возрасту. Например, удалить неиспользуемые образы старше 7 дней:

```
docker image prune -a --filter until=168h
```

### Ловушка: остановленные контейнеры удерживают образы <a name="link_6"></a>

Ситуация «удалил сервис, а место не освободилось» часто объясняется тем, что остались остановленные контейнеры. Они удерживают ссылку на образ и Docker не считает этот образ неиспользуемым.

```
docker ps -a
```

Удалить остановленные контейнеры:

```
docker container prune
```

## Builder cache (BuildKit): почему сборки Dockerfile раздувают диск <a name="link_7"></a>

**builder cache** — это кэш промежуточных результатов сборки. Он ускоряет повторные сборки, но на активном CI/деплое разрастается быстро, особенно если ранние слои Dockerfile часто меняются.

Посмотреть кэш сборки:

```
docker builder df
```

Очистка «безопасного» кэша (удаляет то, что не нужно для текущих результатов сборки; работающие контейнеры не ломает):

```
docker builder prune
```

Более агрессивная очистка всего builder cache:

```
docker builder prune -a
```

Удобная практика для продовых серверов и CI-нод — чистка по возрасту:

```
docker builder prune --filter until=168h
```

### Как уменьшить рост кэша сборки на будущее <a name="link_8"></a>

Чистка — реактивная мера. Чтобы `overlay2` не раздувался каждую неделю, пересмотрите Dockerfile и контекст сборки:

- Стабильные шаги (установка системных пакетов, зависимостей) — выше, изменчивые (копирование исходников) — ниже.
- Используйте `.dockerignore`, чтобы не отправлять в контекст сборки лишнее (например, node_modules, vendor, логи, артефакты).
- Для зависимостей копируйте lock-файлы отдельно (сначала lock, затем install), чтобы кэш переиспользовался.

Так снижается churn слоёв и количество «почти одинаковых» слоёв, которые занимают место.

## Docker volumes: где прячутся реальные данные <a name="link_9"></a>

В контексте нехватки места **docker volumes** часто важнее, чем кажется. Образы и кэш можно пересоздать, а тома обычно содержат данные БД и пользовательские файлы. Ошибка здесь стоит дорого.

Список томов:

```
docker volume ls
```

Понять, используется ли том и кем:

```
docker volume inspect VOLUME_NAME
```

Если том не используется ни одним контейнером, он считается dangling. Их можно удалить так:

```
docker volume prune
```

Но «dangling» в реальной жизни не всегда означает «ненужный»: вы могли остановить проект на время, удалить контейнеры и планировать поднять снова, рассчитывая на данные в томах. Поэтому перед удалением томов нужна сверка с тем, что должно храниться, и где лежат бэкапы.

### Типовой сценарий утечки томов в docker compose <a name="link_10"></a>

В compose-проектах часто создаются именованные тома, а при смене имени проекта, каталога или `COMPOSE_PROJECT_NAME` появляются новые тома, старые остаются висеть и занимают место. Ещё одна причина — пересоздание сервисов с другими именами томов.

Практика: периодически пробегайтесь по объёму томов, и у каждого тома должен быть «владелец» (сервис/проект) и понятное назначение. Если непонятно, кому принадлежит том, удалять нельзя без расследования.

## Комплексная уборка: docker system prune и почему с ним осторожно <a name="link_11"></a>

Соблазн «одной командой почистить всё» — это `docker system prune`:

```
docker system prune
```

По умолчанию команда удаляет остановленные контейнеры, неиспользуемые сети, dangling-образы и builder cache. Но **не** удаляет тома без дополнительного флага.

С удалением томов:

```
docker system prune --volumes
```

Агрессивный режим (удалит все неиспользуемые образы, не только dangling):

```
docker system prune -a
```

Комбинация `-a` и `--volumes` — это «генеральная уборка», которая на проде требует осознанности: вы потеряете кэши, старые образы и неиспользуемые тома. Часто это приводит к неожиданно долгому восстановлению сервиса из-за повторной загрузки образов и пересборки.

> Если на сервере крутятся базы данных в томах, перед любыми prune-операциями убедитесь, что у вас есть актуальный бэкап и вы точно знаете, где он хранится.

## Почему место не освобождается сразу: частые причины <a name="link_12"></a>

Иногда вы удалили образы и контейнеры, а `df -h` показывает почти то же. Частые причины в эксплуатации:

- **Открытые удалённые файлы**: процесс держит дескриптор, место освободится только после перезапуска процесса.
- **Логи контейнеров**: они лежат не в `overlay2`, а в `/var/lib/docker/containers` и могут быть огромными.
- **Снапшоты/backup-агенты** на уровне хоста: Docker почистился, но файловая система занята другим механизмом.
- **Не Docker**: растёт `/var/log`, дампы, кэши пакетов — и это совпало по времени с деплоем.

Проверка «удалённые, но открытые» файлы:

```
sudo lsof +L1
```

Дальше решение обычно простое: перезапуск конкретного сервиса/контейнера или, в крайнем случае, Docker daemon (с пониманием влияния на прод).

## Безопасный чек-лист очистки для продакшена <a name="link_13"></a>

1. Снимите картину: `docker system df -v` и `sudo du -h -d 1 /var/lib/docker | sort -h`.
2. Удалите остановленные контейнеры, если они точно не нужны: `docker container prune`.
3. Удалите dangling-образы: `docker image prune`.
4. Почистите builder cache по возрасту: `docker builder prune --filter until=168h`.
5. Проверьте тома: `docker volume ls`, точечная ревизия и только затем `docker volume prune`, если вы понимаете, что удаляется.
6. Если место всё ещё не вернулось — проверьте открытые удалённые файлы: `sudo lsof +L1`, и отдельно объём логов контейнеров.

## Стратегия на будущее: держим overlay2 под контролем <a name="link_14"></a>

Чтобы проблема «docker overlay2 занимает всё место» не возвращалась, помогает простая дисциплина:

- Ограничьте рост логов контейнеров (ротация логов драйвера, лимиты по размеру и количеству файлов).
- В CI используйте политику удаления кэша по возрасту и не держите бесконечно промежуточные теги.
- Заведите правило: каждый именованный том должен иметь владельца и назначение (в документации проекта или хотя бы в README).
- Периодически сравнивайте `docker system df` с реальным `du` по `/var/lib/docker`, чтобы быстро ловить аномалии.

И последнее: не пытайтесь «чистить overlay2 руками» удалением каталогов внутри `/var/lib/docker/overlay2`. Docker хранит связность через метаданные, и ручное удаление почти гарантированно приведёт к битым слоям и непредсказуемым ошибкам.
