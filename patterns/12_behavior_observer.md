# Наблюдатель (Издатель-Подписчик, Слушатель, Observer)

![Наблюдатель](./behavior/observer/observer.png)

Наблюдатель - это поведенческий паттерн
проектирования, который создаёт механизм подписки,
позволяющий одним объектам следить и реагировать на
события, происходящие в других объектах.

Паттерн Наблюдатель предлагает хранить внутри объекта
издателя список ссылок на объекты подписчиков, причём
издатель не должен вести список подписки самостоятельно.
Он предоставит методы, с помощью которых подписчики
могли бы добавлять или убирать себя из списка.

![Картинка](./behavior/observer/1.png)

Теперь самое интересное. Когда в издателе будет
происходить важное событие, он будет проходиться по
списку подписчиков и оповещать их об этом, вызывая
определённый метод объектов-подписчиков.
Издателю безразлично, какой класс будет иметь тот или
иной подписчик, так как все они должны следовать общему
интерфейсу и иметь единый метод оповещения.

![Картинка](./behavior/observer/2.png)

Увидев, как складно всё работает, вы можете выделить
общий интерфейс, описывающий методы подписки и
отписки, и для всех издателей. После этого подписчики
смогут работать с разными типами издателей, а также
получать оповещения от них через один и тот же метод.

## Структура

![Структура](./behavior/observer/structure.png)

1. Издатель владеет внутренним состоянием, изменение
которого интересно отслеживать подписчикам. Издатель
содержит механизм подписки: список подписчиков и
методы подписки/отписки.

2. Когда внутреннее состояние издателя меняется, он
оповещает своих подписчиков. Для этого издатель
проходит по списку подписчиков и вызывает их метод
оповещения, заданный в общем интерфейсе подписчиков.

3. Подписчик определяет интерфейс, которым пользуется
издатель для отправки оповещения. В большинстве случаев
для этого достаточно единственного метода.

4. Конкретные подписчики выполняют что-то в ответ на
оповещение, пришедшее от издателя. Эти классы должны
следовать общему интерфейсу подписчиков, чтобы
издатель не зависел от конкретных классов подписчиков.

5. По приходу оповещения подписчику нужно получить
обновлённое состояние издателя. Издатель может передать
это состояние через параметры метода оповещения. Более
гибкий вариант - передавать через параметры весь объект
издателя, чтобы подписчик мог сам получить требуемые
данные. Как вариант, подписчик может постоянно хранить
ссылку на объект издателя, переданный ему в конструкторе.

6. Клиент создаёт объекты издателей и подписчиков, а затем
регистрирует подписчиков на обновления в издателях.

В этом примере Наблюдатель позволяет объекту текстового
редактора оповещать другие объекты об изменениях
своего состояния.

![Структура](./behavior/observer/structure_2.png)

Список подписчиков составляется динамически, объекты
могут, как подписываться на определённые события, так и
отписываться от них прямо во время выполнения
программы.

В этой реализации редактор не ведёт список подписчиков
самостоятельно, а делегирует это вложенному объекту. Это
даёт возможность использовать механизм подписки не
только в классе редактора, но и в других классах
программы.

Для добавления в программу новых подписчиков не нужно
менять классы издателей, пока они работают с
подписчиками через общий интерфейс.

## Применимость

- Когда после изменения состояния одного объекта
требуется что-то сделать в других, но вы не знаете
наперёд, какие именно объекты должны отреагировать.

- Описанная проблема может возникнуть при разработке
библиотек пользовательского интерфейса, когда вам надо
дать возможность сторонним классам реагировать на клики
по кнопкам.
Паттерн Наблюдатель позволяет любому объекту с
интерфейсом подписчика зарегистрироваться на получение
оповещений о событиях, происходящих в объектах-
издателях.

- Когда одни объекты должны наблюдать за другими, но
только в определённых случаях.

- Издатели ведут динамические списки. Все наблюдатели
могут подписываться или отписываться от получения
оповещений прямо во время выполнения программы.

## Преимущества и недостатки

- Издатели не зависят от конкретных классов подписчиков и
наоборот.

- Вы можете подписывать и отписывать получателей на лету.

- Реализует принцип открытости/закрытости.

- __Подписчики оповещаются в случайном порядке.__

## Отношения с другими паттернами

- Цепочка обязанностей, Команда, Посредник и
Наблюдатель показывают различные способы работы
отправителей запросов с их получателями:

  - Цепочка обязанностей передаёт запрос последовательно
через цепочку потенциальных получателей, ожидая, что
какой-то из них обработает запрос.

  - Команда устанавливает косвенную одностороннюю связь
от отправителей к получателям.

  - Посредник убирает прямую связь между отправителями и
получателями, заставляя их общаться опосредованно,
через себя.

  - Наблюдатель передаёт запрос одновременно всем
заинтересованным получателям, но позволяет им
динамически подписываться или отписываться от таких
оповещений.

- Разница между Посредником и Наблюдателем не всегда
очевидна. Чаще всего они выступают как конкуренты, но
иногда могут работать вместе.
Цель Посредника - убрать обоюдные зависимости между
компонентами системы. Вместо этого они становятся
зависимыми от самого посредника. С другой стороны, цель
Наблюдателя - обеспечить динамическую одностороннюю
связь, в которой одни объекты косвенно зависят от других.
Довольно популярна реализация Посредника при помощи
Наблюдателя. При этом объект посредника будет выступать
издателем, а все остальные компоненты станут
подписчиками и смогут динамически следить за событиями,
происходящими в посреднике. В этом случае трудно понять,
чем же отличаются оба паттерна.
Но Посредник имеет и другие реализации, когда отдельные
компоненты жёстко привязаны к объекту посредника. Такой
код вряд ли будет напоминать Наблюдателя, но всё же
останется Посредником.
Напротив, в случае реализации посредника с помощью
Наблюдателя представим такую программу, в которой
каждый компонент системы становится издателем.
Компоненты могут подписываться друг на друга, в то же
время не привязываясь к конкретным классам. Программа
будет состоять из целой сети Наблюдателей, не имея
центрального объекта-Посредника.

## Пример
<!-- <link rel="stylesheet" href="./highlight/styles/atelier-forest-dark.css">
<script src="./highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<pre id="mycode" class="python">
<code> -->

```python
"""
EN: State Design Pattern

Intent: Lets an object alter its behavior when its internal state changes. It
appears as if the object changed its class.

RU: Паттерн Состояние

Назначение: Позволяет объектам менять поведение в зависимости от своего
состояния. Извне создаётся впечатление, что изменился класс объекта.
"""


from __future__ import annotations
from abc import ABC, abstractmethod


class Context(ABC):
    """
    EN: The Context defines the interface of interest to clients. It also
    maintains a reference to an instance of a State subclass, which represents
    the current state of the Context.

    RU: Контекст определяет интерфейс, представляющий интерес для клиентов. Он
    также хранит ссылку на экземпляр подкласса Состояния, который отображает
    текущее состояние Контекста.
    """

    _state = None
    """
    EN: A reference to the current state of the Context.

    RU: Ссылка на текущее состояние Контекста.
    """

    def __init__(self, state: State) -> None:
        self.transition_to(state)

    def transition_to(self, state: State):
        """
        EN: The Context allows changing the State object at runtime.

        RU: Контекст позволяет изменять объект Состояния во время выполнения.
        """

        print(f"Context: Transition to {type(state).__name__}")
        self._state = state
        self._state.context = self

    """
    EN: The Context delegates part of its behavior to the current State object.

    RU: Контекст делегирует часть своего поведения текущему объекту Состояния.
    """

    def request1(self):
        self._state.handle1()

    def request2(self):
        self._state.handle2()


class State(ABC):
    """
    EN: The base State class declares methods that all Concrete State should
    implement and also provides a backreference to the Context object,
    associated with the State. This backreference can be used by States to
    transition the Context to another State.

    RU: Базовый класс Состояния объявляет методы, которые должны реализовать все
    Конкретные Состояния, а также предоставляет обратную ссылку на объект
    Контекст, связанный с Состоянием. Эта обратная ссылка может использоваться
    Состояниями для передачи Контекста другому Состоянию.
    """

    @property
    def context(self) -> Context:
        return self._context

    @context.setter
    def context(self, context: Context) -> None:
        self._context = context

    @abstractmethod
    def handle1(self) -> None:
        pass

    @abstractmethod
    def handle2(self) -> None:
        pass


"""
EN: Concrete States implement various behaviors, associated with a state of the
Context.

RU: Конкретные Состояния реализуют различные модели поведения, связанные с
состоянием Контекста.
"""


class ConcreteStateA(State):
    def handle1(self) -> None:
        print("ConcreteStateA handles request1.")
        print("ConcreteStateA wants to change the state of the context.")
        self.context.transition_to(ConcreteStateB())

    def handle2(self) -> None:
        print("ConcreteStateA handles request2.")


class ConcreteStateB(State):
    def handle1(self) -> None:
        print("ConcreteStateB handles request1.")

    def handle2(self) -> None:
        print("ConcreteStateB handles request2.")
        print("ConcreteStateB wants to change the state of the context.")
        self.context.transition_to(ConcreteStateA())


if __name__ == "__main__":
    # EN: The client code.
    #
    # RU: Клиентский код.

    context = Context(ConcreteStateA())
    context.request1()
    context.request2()

```
<!-- </code>
</pre> -->